[{"title":"WEBGL系列之二维操作","date":"2017-06-07T03:15:45.000Z","path":"2017/06/07/webgl01/","text":"背景介绍 WebGL的技术规范继承自免费和开源的OpenGL标准[是用于渲染2D、3D矢量图形的跨语言、跨平台的API] 具体的说，WebGL是从OpenGL的一个特殊版本OpenGL ES中派生出来的，后者专用于嵌入式计算机，智能手机，家用游戏机等设备。它从OpenGL中移除了许多陈旧无用的旧特性，这使得它在保持轻量级的同时，仍具有足够的能力来渲染出精美的三维图形。 OpenGL2.0开始支持的可编程着色器方法被OpenGL ES2.0继承，成为了WebGL1.0标准的核心部分。而着色器方法或称为着色器，是使用一种类似C的编程语言实现精美的视觉效果。而编写着色器的语言称为着色器语言，WebGL使用OpenGL ES着色器语言，亦即GLSLES。 WebGL规范的建立由Khronos(也负责OpenGL规范的更新和标准化)建立的WebGL工作小组负责。2011年发布了WebGL规范的第一个版本。WebGL2.0处于Editor’s Draft状态，它主要提供与OpenGL3.0新特性的对应，现阶段它并不与WebGL1.0完全向下兼容。 基本概念 WebGL主要是用于渲染2D、3D矢量图形。在进入它的使用细节之前，我们先分析下它到底做了件什么事以及其执行的顺序。 如果你有过一点三模建模方面的经验的话，你就会知道，所有的三维模型都是由点，线，三角形构成的。譬如下面这只超级出名的bunny兔子。模型的精细程度与其面片的数量直接相关，当面片数量足够多时，人类的视觉是无法分辨三角形的。 同理，如果我们打开WebGL的绘图API，我们就会发现，它处理的也是点，线，三角形。那么它是如何由这些最基础的东西构建出整个世界的呢。其实，它主要执行了三方面的操作： 获取顶点坐标 简单图形，可以显示定义 复杂图形，一般会在三维软件导出模型时一同导出 顶点坐标会写入缓冲中等待使用 进行图元装配：即将顶点根据primitive(原始的连接关系）还原成网格结构 在WebGL中，为了使用者对顶点的位置有足够的控制权，提供了一个顶点着色器的东西。它是用上面提到的opengl es编写的，然后以字符串的形式嵌入在js文件中的，在程序开始运行前就已经设置好了 顶点着色器中主要对点的特性进行处理，比如进行坐标的转换等，然后由GPU执行图元装配。此处是以单个点为单位执行的操作，有多少个点，这段程序就会执行多少次 12345var VSHADER_SOURCE = 'void main() &#123;\\n' +'gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n' + //设置坐标，必须'gl_PointSize = 10.0;\\n' + // 设置尺寸，非必需，默认1.0'&#125;\\n'; 进行光栅化：将图转化为一个个栅格组成的图象 上面一部生成了模型的网格形态，但是要呈现实际的模型还需要“着色”，这部分WebGL也为我们提供了片元着色器来进行控制。 片元着色器主要进行材质，颜色的处理等，它会进行逐片元处理过程，片元这边可大概理解为像素(图像的单元) 1234 var FSHADER_SOURCE = 'void main() &#123;\\n' +'gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n' + // 设置颜色'&#125;\\n'; 下面图示为整体流程: GLSE中的数据类型 基本类型 float: 表示浮点数 int： 整型 bool： 布尔类型 齐次坐标: (x, y, z, w) 等价于三维坐标 (x/w, y/w, z/w)，w必需大于等于0，齐次坐标的存在，使得用矩阵乘法来描述顶点变换称为可能，三维图形系统在计算过程中，通常使用齐次坐标来表示顶点的三维坐标，这样能够提高处理三维数据的效率 矢量和矩阵 vec4: 表示由四个浮点数组成的矢量，类似有 vec2,vec3,ivec2,ivec3,ivec4,bvec2,bvec3,bvec4 mat2: 表示22的浮点数元素的矩阵，类似有 mat3,mat4, 注意*列主序 结构体 使用struct，将已存在的类型聚合到一起，就可以定义为结构体 数组 只支持一维数组，而且数组对象不支持pop()和push()等操作 取样器(纹理)：必须通过该类型变量访问纹理，两种基本的取样器类型如下 sampler2D samplerCube 注意：取样器变量只能是uniform变量，或者需要访问纹理的函数 函数 1234返回类型函数名(type0, arg0, type1, arg1, ...typen, argn) &#123; 函数计算 return 返回值&#125; 存储限定字 const: 不可变 attribute: 只能出现在顶点着色器中，只能被声明为全局变量，被用来表示逐点的信息 uniform：可以用在顶点和片元着色器中，必须是全局变量，uniform变量是只读的，它可以是数组和结构体之外的任意类型，它包含了“一致”[即非逐顶点／片元的]的数据 varying: 必须全局，从顶点着色器向片元着色器传输数据，在两个着色器中必须同名同类型 精度限定字 highp: 高精度 mediump: 中精度 lowp: 低精度 可以使用关键字precision来声明着色器的默认精度，这行代码必须在顶点着色器或片元着色器的顶部，格式为precision 精度限定字 类型名称 注意：片元着色器中的float类型没有默认精度，需要手动指定，否则会出现编译错误 预处理指令 预处理指令用来在真正编译之前对代码进行预处理，都以#开始 核心思想 获取WebGL上下文： 123var canvas = document.getElementById('example');var ctx = canvas.getContext('2d');ctx.fillStyle = 'rgba(0, 0, 255, 1.0)'; 初始化着色器： 详细见具体API 1-13部分，具体流程如下: 设置canvas背景色并清除canvas： 12345// 设定背景色，一旦指定了背景色后，背景色就会常驻WebGL系统，在下一次再调用这个函数前不会改变gl.clearColor(0.0, 0.0, 0.0, 1.0); //见API 15// 用背景色清空canvas绘图区域，此方法继承自OpenGL，基于多基本缓冲区模型清空绘图区域，实际上是在清空颜色缓冲区，类似的还有 gl.DEPTH_BUFFER_BIT,gl.STENCIL_BUFFER_BITgl.clear(gl.COLOR_BUFFER_BIT); // 见API16 右手坐标系是WebGL默认的坐标系统 JS与着色器之间传输数据(以attribute举例) 详细见具体API 17-20部分，具体流程如下: 动态传输例子点我, 点我 缓冲区对象 WebGL提供了缓冲区对象，它可以一次性的向着色器传入多个顶点的数据。使用缓冲区对象向顶点着色器传入多个顶点数据的步骤如下: 详细见具体API 21-25部分，注意可以创建多个缓冲区对象 WebGL可绘制的基本图形，主要运用于API 14，对比例子点我 WebGL可以绘制gl.POINTS, gl.LINES, gl.LINE_STRIP, gl.LINE_LOOP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN 七种，它们的绘制顺序如下： 移动、旋转、缩放 对于平移而言，就是对顶点的每个分量加上其在对应轴上平移的距离, 因此就是在顶点着色器中对原有的position加上移动的position即可 123newX = oldX + moveX;newY = oldY + moveY;newZ = oldZ + moveZ; 对于旋转而言，有公式如下[绕Z轴旋转]，因此将顶点着色器中的坐标换为下面的计算即可：注意JS内置的Math.cos()和Math.sin()接受的是弧度制，而并非角度 123newX = oldX * cosβ - oldY * sinβnewY = oldX * sinβ + oldY * cosβnewZ = oldZ 123456'void main() &#123;\\n' +'gl_Position.x = a_Position.x * u_CosB - a_Position.y * u_SinB;\\n' + //设置坐标，必须'gl_Position.y = a_Position.x * u_SinB + a_Position.y * u_CosB;\\n' +'gl_Position.z = a_Position.z;\\n' + 'gl_Position.w = 1.0;\\n' +'&#125;\\n'; 当情况复杂起来后，需要进行矩阵变换，比如根据上面可以得到平移矩阵，旋转矩阵和缩放矩阵如下：之后将它与坐标相乘即可得到变换后的坐标,因为矩阵计算比较复杂，一般情况下都使用封装好的矩阵操作库进行计算 1gl_Position = u_xformMatrix * a_Position ; 动画 根据不同时间确定不同的状态 在每次绘制前，清除上次绘制的内容，并绘制相应状态下的图形 调用requestAnimationFrame(fn)进行持续绘制 颜色之前的所有例子我们都是直接设定了颜色值并传入片元着色器，其颜色值是统一的不变的，但是实际中，我们可能会对不同的点着色不同，因此顶点着色器与片元着色器之间应该有某种联系 实际在顶点着色器与片元着色器中主要执行了两个步骤： 图形装配过程：将孤立的顶点坐标装配成几何图形 光栅化过程：将装配好的几何图形转化为片元 光栅化过程中生成的片元都是带有坐标信息的，调用片元着色器时这些坐标信息也随着片元传了进来，可以通过片元着色器中的内置变量来访问片元的坐标 在WebGL中，如果顶点着色器与片元着色器中有类型和命名都相同的varying变量，那么顶点着色器赋给该变量的值就会自动被传入片元着色器，但是，片元着色器中的v_Color变量和顶点着色器中的v_Color实际并不是一回事，顶点着色器中的v_Color变量在传入片元着色器之前经过了内插过程，所以称为varying 整个颜色的处理过程如下： 纹理 真实世界中的颜色变化是相当细粒度的，我们如果全部通过自己定义来做则会陷入无休止的工作中，因此在三维图形学中，纹理映射就成为了一项关键技术。所谓纹理映射，就是将一张图像映射到一个几何图形的表面上去，它根据纹理图像，为之前光栅化后的每个片元涂上合适的颜色，其中组成纹理图像的像素称为纹素，其具体流程如下： 在执行纹理映射的过程中，会涉及到纹理坐标，WebGL系统中的纹理坐标是二维的，使用st坐标系统。其坐标值与图像自身的尺寸无关，左下角的坐标为(0.0, 0.0), 右下角为(1.0, 0.0), 右上角为(1.0, 1.0), 左上角为(0.0, 1.0)。纹理映射需要顶点着色器和片元着色器的配合，首先在顶点着色器中为每个顶点指定纹理坐标，然后在片元着色器中根据每个片元的纹理坐标从纹理图像中抽取纹理像素颜色。 详细流程见API 27-32，具体代码处理流程如下：在GLSE中运用texture2D(sample2D, sampler, vec2, coord): 来从sample指定的纹理上获取coord指定的纹理坐标处的像素颜色, 修改纹理坐标和映射方式点我, 多重纹理点我 具体API注：文中demo根据WebGL编程指南demo改编而来 gl.createShader(type): 创建由type指定的着色器对象，type的值分别为gl.VERTEX_SHADER表示顶点着色器 gl.FRAGMENT_SHADER表示片元着色器 gl.shaderSource(shader, source): 将source指定的字符串形式的代码传入shader指定着色器，如果之前已经向shader传入过代码了，旧的代码将会被替换掉 gl.compileShader(shader): 编译shader指定的着色器中的源代码 gl.getShaderParameter(shader, pname): 获取shader指定的着色器中，pname指定的参数信息pname: 指定待获取参数的类型，可以是gl.SHADER_TYPE gl.DELETE_STATUS或者gl.COMPILE_STATUS，根据pname的不同，返回不同的值 gl.getShaderInfoLog(shader): 获取shader指定的着色器的信息日志 gl.deleteShader(shader): 如果不需要这个着色器，可以用gl.deleteShader()函数来删除着色器，注意，如果着色器对象还在使用，那么deleteShader()并不会立刻删除着色器而是要等到程序对象不再使用该着色器后，才将其删除 gl.createProgram(): 创建程序对象 gl.attachShader(program, shader): 将shader指定的着色器对象分配给program指定的程序对象，着色器在附给程序对象前，并不一定要为其指定代码或进行编译(也就是说，把空的着色器附给程序对象也是可以的) gl.linkProgram(program): 连接program指定的程序对象中的着色器进行这一步的目的是确保： 顶点着色器和片元着色器的varying变量同名同类型，且一一对应 顶点着色器对每个varying变量赋了值 顶点着色器和片元着色器中的同名uniform变量也是同类型的 着色器中的attribute变量，uniform变量和varying变量的个数没有超过着色器的上限 gl.getProgramParameter(program, pname): 获取pname指定的程序对象中pname指定的参数信息。返回值随着pname的不同而不同pname：gl.DELETE_STATUS gl.LINK_STATUS gl.VALIDATE_STATUS gl.ATTACHED_SHADERS gl.ACTIVE_ATTRIBUTES gl.ACTIVE_UNIFORMS, 根据pname的不同，返回值不同, 程序对象即使连接成功了，也有可能运行失败，比如没有为取样器分配纹理单元。这些错误是在运行阶段而不是连接阶段产生的 gl.getProgramInfoLog(program): 获取program指定的程序对象的信息日志 gl.deleteProgram(program): 删除程序对象 gl.useProgram(program): 告知WebGL系统绘制时使用program指定的程序对象 gl.drawArrays(mode, first, count): 按照mode参数指定的方式绘制图形(gl.POINTS, gl.LINES, gl.LINE_STRIP, gl.LINE_LOOP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN), first: 指定从哪个顶点开始绘制 整型, count: 指定绘制多少个点 整型 gl.clearColor(red, green, blue, alpha): 确定当清除颜色buffer时使用的颜色 gl.clear(mask): 指定被清除的buffer，可能的值gl.COLOR_BUFFER_BIT，gl.DEPTH_BUFFER_BIT，gl.STENCIL_BUFFER_BIT gl.getAttribLocation(program, name): 获取由name参数指定的attribute变量的存储地址, program: 指定包含顶点着色器和片元着色器的着色器程序对象, name: 指定想要获取其存储地址的attribute变量的名称 gl.vertexAttrib3f(location, v0, v1, v2): 将数据(v0, v1, v2)传给由location参数指定的attribute变量, gl.vertexAttribXf是一系列同族函数，其中X可以为1，2，3，4，无论哪一个，第四个值都为1.0，其他未填位填充0.0, gl.vertexAttribXv是其矢量版本，接受类型化数组, gl.vertexAttrib 基础函数名 x 参数个数 v参数类型 还能够有gl.vertexAttrib[123]f这种用法 gl.getUniformLocation(program, name): 与API17类似 gl.uniform[1234][fi]v: 与API18类似 gl.createBuffer(): 创建缓冲区对象, 这一步的结果是WebGL系统中多了一个新创建出来的缓冲区对象 gl.bindBuffer(target, buffer): 允许使用buffer表示的缓冲区对象并将其绑定到target表示的目标上，target: gl.ARRAY_BUFFER 表示缓冲区对象中包含了顶点的数据，gl.ELEMENT_ARRAY_BUFFER表示缓冲区对象中包含了顶点的索引值，buffer: 指定之前由gl.createBuffer()返回的待绑定的缓冲区对象将缓冲区对象绑定到目标。这个目标表示缓冲区对象的用途, 我们不能直接向缓冲区写入数据，而只能向目标写入数据，所以要向缓冲区写入数据，必须先绑定。 gl.bufferData(target, ArrayBufferView srcData, usage): 这个API在WebGL1.0和2.0上有所不同，具体见规范。总的来说是开辟存储空间，向绑定在target上的缓冲区对象写入数据data gl.vertexAttribPointer(index, size, type, normalized, stride, offset): 将绑定到target的缓冲区对象分配给由location指定的attribute变量, size: 指定缓冲区中每个顶点的分量个数(1-4), type: 指定数据格式 [gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT], normalized: 传入true, false表明是否将非浮点数的数据归一化到[0, 1]或[-1, 1]区间, stride: 指定相邻两个顶点间的字节数，默认0, offset: 指定缓冲区对象中的偏移量(以字节为单位) gl.enableVertexAttribArray(index): 开启index指定的attribute变量，链接变量与分配给它的缓冲区对象，使顶点着色器能够访问缓冲区内的数据 gl.uniformMatrix[234]x[234]fv(location, transpose, array…): 将array表示的n*n矩阵分配给由location指定的uniform变量，transpose在WebGL中必须指定为false gl.createTexture(): 创建纹理对象以存储纹理图像 gl.pixelStorei(pname, param): 使用pname和param指定的方式处理加载得到的图片, pname:gl.UNPACK_FLIP_Y_WEBGL: 对图像进行Y轴反转，默认为false; gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL: 将图像RGB颜色值的每一个分量乘以A，默认为false, param: 指定非0(true)或0(false)，必须为整数。使用原因：WebGL纹理坐标系统中t轴的方向和PNG,BMP,JPG等格式图片的坐标系统的Y轴方向是相反的，所以要对纹理图像进行Y轴反转 gl.activeTexture(texture): 激活texture指定的纹理单元 gl.bindTexture(target, texture): 开启texture指定的纹理对象，并将其绑定到target上, 如果已经激活了某个纹理单元，则纹理对象也会绑定到这个纹理单元上; target: gl.TEXTURE_2D gl.TEXTURE_CUBE_MAP;在WebGL中，没法直接操作纹理对象，必须通过将纹理对象绑定到纹理单元上，然后通过操作纹理单元来操作纹理对象 gl.texParameterfi: 将param的值赋给绑定到目标的纹理对象的pname参数上, 具体参数见规定，通常可以不用调用，使用默认值就可以了 gl.texImage2D(target, level, internalformat, format, type, image): 将image指定的图像分配给绑定到目标上的纹理对象","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"2017你好～","date":"2017-01-08T12:51:32.000Z","path":"2017/01/08/2017HELLO/","text":"又一年匆匆走过，这一年说长不长说短不短，但的的确确发生了好多好多事情。先来篇流水帐总结。 被老爹说了n久的驾照终于到手了，并且拿到的第二天就被老爹像拎兔子一样拎出去开了70多公里。 和老爸因为一件现在显而易见已经完全想不起来的事情起了争执，一气之下把齐腰长发剪成了个短的不能再短的发型，完美开启了假小子模式。 回学校后顺利结束了答辩，在等资料处理的漫长的一个月里拉着大鸟去日本走了一遭。在这只有零星早樱的季节吃了超级好吃的美食，看了超级棒的风景，遇见了超级有爱的人，也算满足了小时候的心愿。意大利和日本这两个我在小学毕业写在同学录 最想去的国家 一栏的国家都GET。 之后被老哥约着去菲律宾潜水，计划之外的拿到了初级潜水执照，看到了不一样的风景却依然没有学会游泳，泪目。 4月，繁忙的一个月。拽着啊呜和麦子在陌生的帝都陪我找房子，感受就是贵贵贵……尘埃落定后去广州见了下快五年没见的小燕子～虽然这么久没见平时也没啥联系，但原来的感觉在见面的那刻还是回来了。之后作死的和啊呜去了柬埔寨，三天暴走，看过了千年的文明，也晒的跟块煤炭一样了…… 终于的终于还是入职了，然后就入了RN大坑，痛并快乐着的痛快啊。同事都特别好，毕竟年纪差的不多，玩到一块儿没障碍。去了没看见草的草原，漂了比想象中短的水道，爬了只能看见雾霾的山，为了烤鱼来回三四个小时 ｜ 果然吃货技能点的太高。 有些时候会觉得自己好挫，但貌似这个事情急也没用，只能一步一个脚印来。 七月和麦子看了仙剑一的舞台剧，感觉已经记不起上次看舞台剧是多久了，总之其现在的先进程度还是远远超过了我的预期的（也许是我期待值真心太低了 本来约好和科儿的中秋青岛游因为啊呜的突然到来而取消了，不过来了场说走就走的旅行去了趟兰卡威……人生中第二次进警察局，同时深深的体会到自驾的重要性…… 国庆先去上海见了科儿，接着和两只萌萌的室友一起从杭州去了趟越南，对于给小费的事情咱都完美的坚持了我们的底线，棒棒的，120个赞。这趟旅游重要的不是去哪里而是和谁去～ 16年的最后，集结了浩浩荡荡十多号人一起去东北跨年！零点时刻，我们五只吃着毛肚喝着酒或饮料，就这样毫无防备的被拖入了2017。 你好啊，2017。 PS：自己挖的一大堆坑还是希望能在2017填一填哈，啥日语啊，啥乌克丽丽啊，啥天文观测啊，啥无人机啊 （好吧，发现缺钱是硬伤，好好工作好好赚钱，好好和我爱的人和爱我的人一起过好每一天～","tags":[{"name":"总结","slug":"总结","permalink":"http://memory.lulutia.com/tags/总结/"}]},{"title":"React Native入个小门","date":"2016-05-27T14:36:00.000Z","path":"2016/05/27/RN/","text":"React Native是个啥? 创造者:FaceBook 时间:React.js Conf 2015 上发布，9月推出Android版本 使用范围:用于开发iOS和Android原生应用 基本特点: 用React.js抽象操作系统的原生UI组件，继而代替DOM元素来渲染。–&gt;Learn once, write anywhere 在后台React Native运行在主线程之外，而在另一个专门的后台线程里运行JavaScript引擎，两个线程之间通过异步消息协议来通信。–&gt;具备流畅和反应灵敏的优势 对应技术栈 JSX vs HTML CSS-layout vs css ECMAScript 6 vs ECMAScript 5 React Native View vs DOM 如何玩React Native? 按照React Native官方文档搭建环境，如下有英文版，中文版。模拟器推荐使用Genymotion。IDE推荐使用WebStorm,其注册码在此。整个上述过程中可能遇见的问题如下: $ANDROID_NDK 和 $ANDROID_HOME 没有正确设置: 解决办法：vi .bashrc和.bash_profile 加上 /usr/local/opt/android-ndk和/usr/local/opt/android-sdk,并且source一下这两个文件，然后eoch下上述两个变量是否已经存在。 运行官方案例(即在虚拟机上查看RN各个组件的实际效果)，方法如此链接,可能遇见的问题如下: What went wrong: Execution failed for task &#39;:ReactAndroid:buildReactNdkLib&#39;. 解决办法 安卓新项目起不来 注意下是不是老项目的shell还在运行，需要重新编译链接一次。 运行F8 App方法,其开发指南在此。可能遇见的问题如下: pod install无反应问题。 解决办法,关于CocoaPods使用方法及各种问题强烈推荐下面这篇文章 Could not find com.google.android.gms:play-services-gcm:8.3.0. 解决办法 123 $ adb reverse tcp:8081 tcp:8081error: closed error: closed 原因：对于 Android 5.0 及以上的设备，可以直接运行；对于其以下的版本，按照官方文档，需要按 menu 键或者摇晃手机，在开发菜单中设置一下 dev server 的 IP 地址。 接下来就可以欢快的自己写代码了。写的途中还会遇见各种坑，就具体情况具体分析吧。总结下： 确保相关工具和Android SDK都是最新版本。 确保网络畅通，特别是翻好墙。（此处应有微笑 注意看官方文档及其issue。","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"yeoman建立脚手架","date":"2015-11-03T14:10:00.000Z","path":"2015/11/03/yeoman建立脚手架/","text":"首先你要先安装yeoman，npm install -g yo bower grunt-cli gulp。 generator是一个Node.js的模块。 建立一个写generator的文件，必须命名为generator-name(name是自己取)。比如我建立一个generator-lulutia-react。 npm init来建立一个package.json。 123456789101112131415161718 &#123; \"name\": \"generator-lulutia-react\",//必须generator开头 \"version\": \"0.0.1\", \"description\": \"the bone to build a app\", \"files\": [ \"app\", \"router\" ],//必须是你的generator用到的文件构成的数组 \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ \"yeoman-generator\"//必须有这条 ], \"author\": \"lulutia\", \"license\": \"MIT\"&#125; npm install yeoman-generator --save//yeoman的依赖必须是最新的 默认执行yo name时执行的是app内的内容，yo name:subcommand执行的是其他文件夹里的内容。 yeoman提供两种组织方式来，其一是:./,其二是:generators/，注意第二种方式的package.json内的files要相应修改。 根据提供的基本结构来写自己的脚手架内容 12345678910111213var generators = require('yeoman-generator');module.exports = yeoman.generators.Base.extend(&#123;// The name `constructor` is important hereconstructor: function () &#123;// Calling the super constructor is important so our generator is correctly set upgenerators.Base.apply(this, arguments);// Next, add your custom codethis.option('coffee'); // This method adds support for a `--coffee` flag&#125;&#125;); 我这里用了几个库，Prompts:主要掌管generator与用户的交互 1234567891011121314module.exports = yeoman.generators.Base.extend(&#123;prompting: function () &#123;var done = this.async();this.prompt(&#123; type : 'input', name : 'name', message : 'Your project name', default : this.appname // Default to current folder name&#125;, function (answers) &#123; this.log(answers.name); done();&#125;.bind(this));&#125;&#125;) writing里面用mkdirp建立基本骨架。在app内部建立templates文件夹，通过里面的文件的拷贝建立结构。 1234567mkdirp(\"assets/style\");mkdirp(\"build\"); this.fs.copy( this.templatePath('coffeelint.json'), this.destinationPath('coffeelint.json') ); generator.installDependencies()安装依赖. 在generator-name/文件夹下运行npm link可以使generator在本地可用。 意料之外的问题 yeoman安装的时候表示node和npm的版本都落后了，然后npm这个命令就无法用了……简直了＝＝然后想用brew安装下，结果忘记brew没更新，各种更新无效。 直接用curl -L https://www.npmjs.com/install.sh | sh加上sudo也有问题，还是报权限错误。 决定可以用bower，但强迫症患者觉得这样不完美。可以直接重新下node，但觉得代价太大。 用了比较粗暴的方法，去npm 的github上下载了sh，然后sudo sh /Users/muriel/Downloads/install.sh来安装。完了顺便把brew更新下,把没升级的软件升级了brew update;brew upgrade;brew cleanup。 然后又出来一个问题，npm install按照package.json来安装但是目录结构有问题，原来npm的3开始决定采用扁平化处理，所以之前的代码为了适应这个改变必须要做一些改变。 具体代码","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"ES6 learning 五","date":"2015-11-02T13:36:00.000Z","path":"2015/11/02/ES6-5/","text":"异步操作和Async函数 ES6之前，异步编程的几种方式： 回调函数 事件监听 发布/订阅 Promise对象 其他：Generator函数，Thunk函数。可以用thunkify模块，结合Generator函数，封装一个run函数实现自动化流程管理。co模块(使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象)。async函数，async函数就是Generator函数的语法糖，它的自动执行器不需要用户自己来实现。 感觉上async最好用： 1234567891011async function chainAnimationsAsync(elem, animations) &#123; var ret = null; try &#123; for(var anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; Class 类的内部所有定义的方法，都是不可枚举的（enumerable）。 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 Class表达式：采用Class表达式，可以写出立即执行的Class。 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;;//需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 Class不存在变量提升。 继承：class ColorPoint extends Point {} super关键字，指代父类的实例(即父类的this对象)。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 子类的proto属性，表示构造函数的继承，总是指向父类。子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（proto属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。 Object.getPrototypeOf方法可以用来从子类上获取父类。 子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。通过子类实例的proto.proto属性，可以修改父类实例的行为。 ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。 存值函数和取值函数是设置在属性的descriptor对象上的。 父类的静态方法，可以被子类继承。 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。ES6明确规定，Class内部只有静态方法，没有静态属性。 ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。子类继承父类时，new.target会返回子类。 Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。 修饰器 修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。 1234567@decoratorclass A &#123;&#125;// 等同于class A &#123;&#125;A = decorator(A) || A; 修饰器不仅可以修饰类，还可以修饰类的属性。修饰器有注释的作用。 由于存在函数提升，使得修饰器不能用于函数。 一些常用的库：core-decorators.js, traits-decorator… Module 模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 export语句输出的值是动态绑定，绑定其所在的模块。 ES6支持多重加载，即所加载的模块中又加载其他模块。 import命令具有提升效果，会提升到整个模块的头部，首先执行。 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 module命令可以取代import语句，达到整体输入模块的作用。module命令后面跟一个变量，表示输入的模块定义在该变量上。 export default命令，为模块指定默认输出。使用export default时，对应的import语句不需要使用大括号；不使用export default时，对应的import语句需要使用大括号。一个模块只能有一个默认输出，因此export deault命令只能使用一次。 模块之间也可以继承。 一些常用的库：ES6 module transpiler, SystemJS 编程风格 let取代var 在let和const之间，建议优先使用const，let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的。 严格模式 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 使用数组成员对变量赋值，优先使用解构赋值。 函数的参数如果是对象的成员，优先使用解构赋值。 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 使用扩展运算符（…）拷贝数组。 使用Array.from方法，将类似数组的对象转为数组。 立即执行函数可以写成箭头函数的形式。 那些需要使用函数表达式的场合，尽量用箭头函数代替。 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 使用默认值语法设置函数参数的默认值。 注意区分Object和Map，只有模拟实体对象时，才使用Object。如果只是需要key:value的数据结构，使用Map。因为Map有内建的遍历机制。 总是用class，取代需要prototype操作。 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 使用export取代module.exports。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 如果模块默认输出一个函数，函数名的首字母应该小写。如果模块默认输出一个对象，对象名的首字母应该大写。","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"ES6 learning 四","date":"2015-10-23T12:22:00.000Z","path":"2015/10/23/ES6-4/","text":"Iterator和for..of循环 Iterator的作用有三个： 一是为各种数据结构，提供一个统一的、简便的访问接口； 二是使得数据结构的成员能够按某种次序排列； 三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。 在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。调用Symbol.iterator方法，就会得到当前数据结构默认的遍历器生成函数。 字符串是一个类似数组的对象，也原生具有Iterator接口。 JavaScript原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值。Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。 对于字符串来说，for…of循环还有一个特点，就是会正确识别32位UTF-16字符。 对于普通的对象，for…of结构不能直接使用，会报错，必须部署了iterator接口后才能使用。一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。另一个方法是使用Generator函数将对象重新包装一下。 for…in循环主要是为遍历对象而设计的，不适用于遍历数组。 Generator函数 Generator函数是ES6提供的一种异步编程解决方案,Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 Generator函数是一个普通函数，但是有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。yield语句不能用在普通函数中，否则会报错。yield语句如果用在一个表达式之中，必须放在圆括号里面。yield语句用作函数参数或赋值表达式的右边，可以不加括号。for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象。 如果Generator函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。如果Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历，否则遍历直接终止。但是，如果使用throw命令抛出错误，不会影响遍历器状态。 如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。 yield*语句，用来在一个Generator函数里面执行另一个Generator函数。 可以并行执行、交换执行权的线程（或函数），就称为协程。如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。 Promise对象 所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。 Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。 Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise实例具有then方法，也就是说，then方法是定义在原型对象,then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。采用链式的then，可以指定一组按照次序调用的回调函数。 Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"ES6 learning 三","date":"2015-10-22T02:09:00.000Z","path":"2015/10/22/ES6-3/","text":"对象的扩展 ES6允许在对象之中，只写属性名。这时，属性值等于属性名所代表的变量。除了属性简写，方法也可以简写。 ES6允许字面量定义对象时，用表达式作为对象的属性名或方法名，即把表达式放在方括号内。注意，属性名表达式与简洁表示法，不能同时使用，会报错。 Object.is用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign只拷贝自身属性，不可枚举的属性（enumerable为false）和继承的属性不会被拷贝。 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 proto属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。 Object.observe()，Object.unobserve()。 目前，ES7有一个提案，将rest参数/扩展运算符（…）引入对象。 Symbol ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。 Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。let s=Symbol();。 Symbol值不能与其他类型的值进行运算，会报错。但是，Symbol值可以显式转为字符串。 注意，Symbol值作为对象属性名时，不能用点运算符。同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。 Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名。 Symbol.for方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。Symbol.keyFor方法返回一个已登记的Symbol类型值的key。 Symbol.hasInstance, Symbol.isConcatSpreadable,Symbol.replace,Symbol.search,Symbol.split,Symbol.iterator,Symbol.toPrimitive,Symbol.toStringTag,Symbol.unscopables Proxy和Reflect Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。将Object对象的一些明显属于语言层面的方法，放到Reflect对象上。 Set Map Set,它类似于数组，但是成员的值都是唯一的，没有重复的值。Set内部判断两个值是否不同，使用的算法类似于精确相等运算符（===），这意味着，两个对象总是不相等的。 Array.from方法可以将Set结构转为数组。 由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。 WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。首先，WeakSet的成员只能是对象，而不能是其他类型的值。其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。 ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 set方法返回的是Map本身，因此可以采用链式写法。 WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。 WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"ES6 learning 二","date":"2015-10-21T14:16:00.000Z","path":"2015/10/21/ES6-2/","text":"字符串的扩展 JavaScript可以用\\uxxxx表示一个字符，但局限于\\u0000–\\uFFFF,超过就得用双字节。ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 1\"\\u&#123;20BB7&#125;\" // \"𠮷\" JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。charAt方法无法读取字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。它的逆过程通过String.fromCodePoint实现，弥补了String.fromCharCode的溢出问题。 12charCodeAt -&gt; codePointAtString.fromCharCode -&gt; String.fromCodePoint for..of遍历字符串，可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 ES7提供了字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。 ES6提供String.prototype.normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 includes(),startsWith(),endsWith(),repeat() 模板字符串：模板字符串（template string）是增强版的字符串，用反引号（`）标识。如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。模板字符串中嵌入变量，需要将变量名写在${}之中。使用&lt;%= … %&gt;输出JavaScript表达式。 标签模板：模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 数值的扩展 ES6提供了二进制和八进制数值的新的写法，分别用前缀0b和0o表示。 Number.isFinite(),Number.isNaN() 区别于全局的isFinite()与isNaN()，他们不调用Number()方法进行转换。 Number.parseInt(),Number.parseFloat() Number.isInterger(),Number.EPSILON Number.MAX_SAFE_INTERGER,Number.MIN_SAFE_INTERGER,Number.isSafeInteger() Math新增的方法： Math.trunc()//去除小数部分，返回整数部分 Math.sign()//判断一个数到底是正数，负数，还是0 Math.cbrt()//计算一个数的立方根 Math.clz32()//Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0 Math.imul()//Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。主要解决的精度问题。 Math.fround()//返回一个数的单精度浮点数形式 Math.hypot()//返回所有参数的平方和的平方根 Math.expm1(),Math.log1p(),Math.log10(),Math.log2() Math.sinh(x),Math.cosh(x),Math.tanh(x),Math.asinh(x),Math.acosh(x),Math.atanh(x) ES7新增了一个指数运算符（）,```2 3 = 222```。 数组的扩展 Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 扩展运算符（…）也可以将某些数据结构转为数组,var args = [...arguments];。 Array.of方法用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。只有当参数个数不少于2个，Array()才会返回由参数组成的新数组。 copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 find()//直接返回数组元素；findIndex()//返回数组元素索引 fill方法使用给定值，填充一个数组。 数组实例的entries()，keys()和values()。 数组实例的includes()。 注意对数组的空位的处理变化了。 数组推导[超级赞的功能] Array.observe(),Array.unobserve()这两个方法用于监听（取消监听）数组的变化，指定回调函数。 函数的扩展 ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。参数默认值所处的作用域，不是全局作用域，而是函数作用域。参数变量是默认声明的，所以不能用let或const再次声明。 ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。所有数组特有的方法都可以用于这个变量。注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。函数的length属性，不包括rest参数。 扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。 函数的name属性，返回该函数的函数名。bind返回的函数，name属性值会加上“bound ”前缀。 ES6允许使用“箭头”（=&gt;）定义函数。 函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。由于this在箭头函数中被绑定，所以不能用call()、apply()、bind()这些方法去改变this的指向。 不可以当作构造函数。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 函数绑定:函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。由于双冒号运算符返回的还是原对象，因此可以采用链式写法。 尾调用:指某个函数的最后一步是调用另一个函数。“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。 ES7有一个提案，允许函数的最后一个参数有尾逗号（trailing comma）。","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"JavaScript中的delete一探","date":"2015-10-20T04:36:00.000Z","path":"2015/10/20/JavaScript-delete/","text":"核心内容借鉴自下面的网址 delete一般用法： 删除对象的属性 1234var a=&#123;p:21&#125;;console.log(a.p);//21delete a.p;//trueconsole.log(a.p);//undefined 无法删除一般的变量 1234var x=13;console.log(x);//13delete x;//falseconsole.log(x);//13 无法删除函数 123var p=function()&#123;&#125;;delete p;//falsetypeof(p);//function 造成上述表现的原因 在ECMAScript中，有三种可执行代码类型：全局代码、函数代码、eval代码。对于以上几种代码都有相应的执行上下文。每个执行上下文又对应有变量对象，在源代码中声明的变量和方法实际上都是作为属性被加入到与当前上下文相关联的这个对象当中。 全局代码时：变量对象是全局对象。 1234567891011121314151617181920212223242526 var global=33; window.global;//33 global===window.global;//true function uu()&#123;&#125;; typeof window.uu;//&quot;function&quot; window.uu===uu;//true ``` * 函数代码：此时有活动对象的概念。**在函数段中，并不是只有显式声明的变量和函数会成为活动对象的属性，对于每个函数中隐式存在的arguments对象（函数的参数列表）也是一样的**。 * eval函数：进入eval代码时并不会新建新的变量对象，而是沿用当前的环境。* 每一个变量属性都可以有以下任意多个属性: ReadOnly, DontEnum, DontDelete, Internal。在声明变量或者函数时，他们都变成了当前上下文对象的属性，这些属性在创建时 都带有DontDelete标记；但是显式或者隐式的赋值语句所产生的属性并不会带有这个标记。 ```JavaScript:var test=1;delete test;//falsetest2 = 2;delete test2;//true``` * 一些内建的对象是自动持有DontDelete这个标记的，从而不能被删除，比如函数内的arguments，函数的传入参数以及函数的length属性。* 属性标记诸如DontDelete是在这个属性被创建的时候 产生的，之后对该属性的任何赋值都不会改变此属性的标记。```JavaScript:function y()&#123;&#125;;delete y;//falsey=1;delete y;//falsetypeof y;//&quot;number&quot; 在eval中声明的变量创建时都不会带有DontDelete标记,在函数内部也一样。 12eval(&apos;var ii=34;&apos;);delete ii;//true 在Firebug控制台中的代码最终将通过eval执行，而不是作为全局代码或函数代码。 IE6-8中的问题： 通过全局this变量去删除属性(delete this.x)总会出错 直接删除该属性(delete x)时： 如果x是通过全局this赋值产生会(this.x=1)导致错误； 如果x通过显式声明创建(var x=1)则delete会像我们预料的那样无法删除并返回false； 如果x通过非声明式赋值创建(x=1)则delete可以正常删除。 原因： “IE的全局变量对象是通过JScript实现，而一般的全局变量是由host实现的。” 对于宿主对象而言，delete操作的结果是不可预料的。因为宿主对象根据不同浏览器的实现允许有不同的行为，这其中包括了delete。 strict mode采用了更主动并且描述性的方法，而不是简单的忽略无效的删除操作。(比如平常删除一个不存在的变量会return true;但使用严格模式后会报错。)","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"面试回忆360","date":"2015-10-15T12:38:00.000Z","path":"2015/10/15/memory1/","text":"一大早就跑南京去面360，完全高铁当公交的节奏……但是，我穷啊＝＝。总的来说面的特别的不好，还不是自己弱，怪谁啊，稍微纪录下吧。 岗位：web前端工程师 笔试题还记得吗？ 会哪些语言？ 啥叫面向对象？ 算法和数据结构怎么样？ 用JavaScript手写一个排序。 学过哪些课程？这个课程教了些啥？ 操作系统熟吗？ 计算机如何实现减法的？ 数据库熟吗？了解哪些数据库？ 说一下数据库范式？ 说一下tcp/IP分层模型。 说一下tcp三次握手协议。 说一下应用层中的协议对应的网络层的协议。 在TCP/IP协议中如何实现的IP的映射。 说一下对JavaScript原型链的理解。 用代码实现js中的继承。 说一下对闭包的理解。让写程序实现一个计时器每隔一秒按顺序输出1-60中的一个值。 说一下对作用域的理解，然后给了个程序，问输出。 ECMAScript有哪些新变化。 ECMAScript5最近加了哪些属性。 现在主流的是ECMAScript几。 如何理解html的语义化。 css的选择器有哪些？ 有哪些行内元素标签？ 一行两个div，第一个固宽，用css实现后面的自适应。 实现知道长宽的div的垂直居中。 问了些项目相关。 ————————————————————————————————————————————————————————————————总的感觉是他们希望招全栈工程师，当然我自己弱也是事实，os的确没系统的学过，数据库和网络学的太久远了忘记的差不多了，c++那些快两年没用过了也是退化的很严重啊。当然之前没想到前端会面这些所以也没系统的复习＝＝打算工作决定后用接下来的半年好好系统的整理下整个计算机的知识，维护一个完整的知识网络。因为觉得这个还是很重要的一件事情。最后提问阶段，我问了两个问题： 其一，刚才面试问的很宽泛，问题还没说完，面试官来了一句：我不问你这些问你哪些……，（其实我想说的是他们怎么看待重要性的问题的……）伤不起。 知趣的问第二个问题，你们那边主要用什么技术，面试官来了一句：还不就是那一套……（我真心没法描述我当时心里的状况）……我接着说比如node这些会涉及吗？他来了句当然会涉及各种技术，比如可能进去会写PHP啊，总之大概意思就是全栈是趋势blabla。 嘛～只能说不适合啰；我对计算机基础知识的掌握达不到面试官的要求，同样面试官对我提问的回答也达不到我的预期。不过还是给学校丢人了(大哭状)","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"面试","slug":"面试","permalink":"http://memory.lulutia.com/tags/面试/"}]},{"title":"(数据结构与算法JavaScript描述)读书笔记","date":"2015-10-13T08:06:00.000Z","path":"2015/10/13/note-structure01/","text":"数组 判断是否数组：Array.isArray(sth); []创建数组的效率比Array构造函数高; 浅复制 VS 深复制； 字符串生成数组:split();数组的字符串表示:join()/toString() sort()是按照字典顺序对元素进行排序的，因此它假定元素都是字符串类型的，按照数字大小进行排序的一般如下： 12345function compare(num1,num2)&#123; return num1 - num2;&#125;var nums = [3,2,5,7,88];nums.sort(compare); 迭代器方法: forEach();every();some();reduce()–累加；reduceRight();map();filter()–返回一个新数组，该数组包含应用该函数后结果为true的元素; 创建多维数组的一般办法 1234567891011function matrix(numrows,numcols,initial)&#123; var arr = []; for(var i = 0; i &lt; numrows; i++)&#123; var columns = []; for(var j = 0; j &lt; numcols; j++)&#123; columns[j] = initial; &#125; arr[i] = columns; &#125; return arr;&#125; 列表 如果数据结构非常复杂。列表的作用就没有那么大了。 如果数据储存的顺序不重要，也不必对数据进行查找，那么列表就很好。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798function List()&#123; this.listSize = 0;//列表长度 this.pos = 0;//列表的当前位置 this.dataStore = [];//初始化一个空数组来保存列表元素 this.clear = clear; this.find = find; this.toString = toString; this.insert = insert; this.append = append; this.remove = remove; this.front = front; this.end = end; this.prev = prev; this.next = next; this.length = length; this.currPos = currPos; this.moveTo = moveTo; this.getElement = getElement; this.contains = contains;&#125;function append(element)&#123; this.dataStore[this.listSize++] = element;&#125;function find(element)&#123; for(var i=0;i &lt; this.dataStore.lenhgth;i++)&#123; if(this.dataStore[i] == element)&#123; return i; &#125; &#125; return -1;&#125;function remove(element)&#123; var foundAt = this.find(element); if(foundAt &gt; -1)&#123; this.dataStore.splice(found,1); --this.listSize; return true; &#125; return false;&#125;function length()&#123; return this.listSize;&#125;function toString()&#123; return this.dataStore;&#125;function insert(element, after)&#123; var insertPos = this.find(after); if(insertPos &gt; -1)&#123; this.dataStore.splice(insertPos+1, 0, element); ++this.listSize; return true; &#125; return false;&#125;function clear()&#123; delete this.dataStore;//关于delete的用法重启一章描述 this.dataStore = []; this.listSize = this.pos = 0;&#125;function contains(element)&#123; for(var i=0; i&lt;this.dataStore.length;i++)&#123; if(this.dataStore[i] == element)&#123; return true; &#125; &#125; return false;&#125;function front()&#123; this.pos = 0;&#125;function end()&#123; this.pos = this.listSize - 1;&#125;function prev()&#123; if(this.pos &gt; 0)&#123; --this.pos; &#125;&#125;function next()&#123; if(this.pos&lt;this.listSize-1)&#123; ++this.pos; &#125;&#125;function currPos()&#123; return this.pos;&#125;function moveTo(position)&#123; this.pos = position;&#125;function getElement()&#123; return this.dataStore[this.pos];&#125;迭代器：var names = [2,4,5,5];for(names.front();names.currPos()&lt;names.length();names.next())&#123; console.log(names.getElement());&#125; 栈123456789101112131415161718192021222324function Stack()&#123; this.dataStore = []; this.top = 0; this.push = push; this.pop = pop; this.peek = peek;&#125;function push(element)&#123; this.dataStore[this.top++] = element;&#125;function pop()&#123; return this.dataStore[--this.top];&#125;function peek()&#123; return this.dataStore[this.top-1];&#125;function length()&#123; return this.top;&#125;function clear()&#123; delete this.dataStore;//关于delete的用法重启一章描述 this.dataStore = []; this.top = 0;&#125; 将数字转化为二至九进制的数字 123456789101112function mulBase(num, base)&#123; var s = new Stack(); do&#123; s.push(num%base); num = Math.floor(num/=base); &#125;while(num&gt;0); var converted = \"\"; while(s.length()&gt;0)&#123; converter += s.pop(); &#125; return converted;&#125; 回文判断 12345678910111213141516function isPalindrome(word)&#123; var s = new Stack(); for(var i=0; i&lt;word.length; i++)&#123; s.push(word[i]); &#125; var rword = \"\"; while(s.lenght()&gt;0)&#123; rword += s.pop(); &#125; if(word == rword)&#123; return true; &#125; else&#123; return false; &#125;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"算法","slug":"算法","permalink":"http://memory.lulutia.com/tags/算法/"}]},{"title":"leetcode-JavaScript实现part2","date":"2015-10-12T10:09:00.000Z","path":"2015/10/12/leetcode2/","text":"其他见part1Merge Two Sorted Lists https://leetcode.com/problems/merge-two-sorted-lists/ Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(l1, l2) &#123; var resultNode = new ListNode(0); var result = resultNode; if(l1===null&amp;&amp;l2===null)&#123; return null; &#125; while(l1!==null||l2!==null)&#123; if(l1===null)&#123; result.val = l2.val; l2 = l2.next; if(l2!==null)&#123; result.next = new ListNode(0); result = result.next;&#125; &#125; else if(l2===null)&#123; result.val = l1.val; l1 = l1.next; if(l1!==null)&#123; result.next = new ListNode(0); result = result.next;&#125; &#125; else&#123; if(l1.val&lt;=l2.val)&#123; result.val = l1.val; l1 = l1.next; if(l1!==null||l2!==null)&#123; result.next = new ListNode(0); result = result.next;&#125; &#125; else&#123; result.val = l2.val; l2 = l2.next; if(l1!==null||l2!==null)&#123; result.next = new ListNode(0); result = result.next;&#125; &#125; &#125; &#125; return resultNode;&#125;; Remove Duplicates from Sorted Array https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 注意返回的是length 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; if(nums.length===0)&#123; return 0; &#125; if(nums.length===1)&#123; return nums.length; &#125; for(var i=1 ;i&lt;nums.length;i++)&#123; if(nums[i]===nums[i-1])&#123; nums.splice(i,1); i = i-1; &#125; &#125; return nums.length;&#125;; Remove Element https://leetcode.com/problems/remove-element/ Given an array and a value, remove all instances of that value in place and return the new length.The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; var count = nums.length; if(nums.length===0)&#123; return null; &#125; for(var i=0; i&lt;nums.length;i++)&#123; if(nums[i]===val)&#123; nums.splice(i,1); i = i-1; count = count-1; &#125; &#125; return count;&#125;; Implement strStr() https://leetcode.com/problems/implement-strstr/ mplement strStr().Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 123456789101112131415/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var strStr = function(haystack, needle) &#123; if(haystack.length&lt;needle.length)&#123; return -1; &#125; if(haystack.length===0&amp;&amp;needle.length&gt;0)&#123; return -1; &#125; return haystack.indexOf(needle); &#125;; Valid Sudoku https://leetcode.com/problems/valid-sudoku/ Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. 简单的说确认是否是有效的数独。即满足每一行、每一列、每一个粗线宫内的数字均含1-9，不重复。 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;character[][]&#125; board * @return &#123;boolean&#125; */var isValidSudoku = function(board) &#123; var array3 = []; for(var q=0;q&lt;3;q++)&#123; array3[q] = []; for(var f=0 ; f&lt;3;f++)&#123; array3[q][f] = [];&#125; &#125; for(var i=0;i&lt;9;i++)&#123; var array = []; var array2 = []; for(var j=0;j&lt;9;j++)&#123; var fir = parseInt(i/3); var sec = parseInt(j/3); if(array3[fir][sec].indexOf(board[i][j])!==-1&amp;&amp;board[i][j]!==\".\")&#123; return false; &#125; if(array.indexOf(board[i][j])!==-1&amp;&amp;board[i][j]!==\".\")&#123; return false; &#125; if(array2.indexOf(board[j][i])!==-1&amp;&amp;board[j][i]!==\".\")&#123; return false; &#125; else &#123; array3[fir][sec].push(board[i][j]); array.push(board[i][j]); array2.push(board[j][i]); &#125; &#125; &#125; return true;&#125;; Length of Last Word https://leetcode.com/problems/length-of-last-word/ Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example, Given s = “Hello World”,return 5. 123456789101112131415161718192021/** * @param &#123;string&#125; s * @return &#123;number&#125; */// var lengthOfLastWord = function(s) &#123;// s = s.trim();// if(s[s.length-1]===\" \")&#123;return 0;&#125;// var arr = s.split(\" \");// return arr[arr.length-1].length;// &#125;;// 上面这种效率太低了var lengthOfLastWord = function(s) &#123; s = s.trim(); if(s[s.length-1]===\" \")&#123;return 0;&#125; for(var i=s.length-1;i&gt;=0;i--)&#123; if(s[i]===\" \")&#123; return s.length-1-i; &#125; &#125; return s.length;&#125;; Plus One https://leetcode.com/problems/plus-one/ Given a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list. 123456789101112131415161718192021222324/** * @param &#123;number[]&#125; digits * @return &#123;number[]&#125; */ //之前用字符串parseInt来做会越界var plusOne = function(digits) &#123; if(digits.length===0)&#123; return [1]; &#125; for(var i=0;i&lt;digits.length;i++)&#123; if(digits[digits.length-i-1]+1&gt;=10)&#123; digits[digits.length-i-1] = 0; if(digits.length-i-1-1&lt;0)&#123; digits.unshift(1); return digits; &#125; flag = true; &#125; else &#123; digits[digits.length-i-1]=digits[digits.length-i-1]+1; return digits; &#125; &#125;&#125;; Climbing Stairs https://leetcode.com/problems/climbing-stairs/ You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 测试可知，其实是一个斐波拉契数列n为1，2，3，4，5时，结果为1，2，3，5，8. 1234567891011121314151617181920/** * @param &#123;number&#125; n * @return &#123;number&#125; */var climbStairs = function(n) &#123; function step(n)&#123; var a=1,b=2; if(n===2)&#123;return b;&#125; if(n===1)&#123;return a;&#125; var sum; n -= 2; while(n--)&#123; sum = a+b; a = b; b = sum; &#125; return sum; &#125; return step(n);&#125;; Remove Duplicates from Sorted List https://leetcode.com/problems/remove-duplicates-from-sorted-list/ Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1-&gt;1-&gt;2, return 1-&gt;2. Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 注意的点：处理最后一位如果为重复的情况,所以放了一个暂时变量tmp，因为链表是有序的，所以只需要对比head的下一个与result的最后一个是否一样。 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var deleteDuplicates = function(head) &#123; if(head===null)&#123;return [];&#125; var outNode = new ListNode(0); var result = outNode; result.val = head.val; while(head.next!==null)&#123; var tmp = head.next; if(tmp.val!==result.val)&#123; result.next = new ListNode(0); result = result.next; result.val = tmp.val; head = head.next &#125; else&#123; head = head.next; &#125; &#125; return outNode;&#125;; Merge Sorted Array https://leetcode.com/problems/merge-sorted-array/ Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 注意的点： 可能数组中有0，但是0是不计入数量的，所以最好一开始就将不符合长度的值去掉。 另外需要处理nums1已经遍历完了，但是nums2还有剩的情况，直接将nums2剩下的加入nums1中，因为本来他们两个就是有序的。 注意不要return。 splice的用法好好体会，记得是在第一个值之前插入。 12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123; nums1.splice(m); nums2.splice(n); var pp=0; for(var i=0;i&lt;n;i++)&#123; for(var j=pp;j&lt;m;j++)&#123; if(nums2[i]&lt;=nums1[j])&#123; if(j===0)&#123; nums1.unshift(nums2[i]); pp = j + 1; m = m + 1; break; &#125; else&#123; nums1.splice(j,0,nums2[i]); pp = j+1; m = m + 1; break; &#125; &#125; &#125; if(j&gt;=m)&#123;nums1.push(nums2[i])&#125; &#125;&#125;;","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"算法","slug":"算法","permalink":"http://memory.lulutia.com/tags/算法/"}]},{"title":"ES6 learning","date":"2015-10-11T14:38:00.000Z","path":"2015/10/11/ES6/","text":"Environment Prepare Bable node –harmony node –v8-options | grep harmony npm install –global babel babel-node babel-node es6.js babel es6.js -o es5.js babel -d build-dir source-dir babel -d build-dir source-dir -s use Bable in browser: 1234&lt;script src=\"node_modules/babel-core/browser.js\"&gt;&lt;/script&gt;&lt;script type=\"text/babel\"&gt;// Your ES6 code&lt;/script&gt; Traceur 12345678910111213 &lt;!-- 加载Traceur编译器 --&gt;&lt;script src=\"http://google.github.io/traceur-compiler/bin/traceur.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;!-- 将Traceur编译器用于网页 --&gt;&lt;script src=\"http://google.github.io/traceur-compiler/src/bootstrap.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;!-- 打开实验选项，否则有些特性可能编译不成功 --&gt;&lt;script&gt; traceur.options.experimental = true;&lt;/script&gt;&lt;script type=\"module\"&gt; //Your ES6 code&lt;/script&gt; npm install -g traceur traceur es6.js traceur –script es6.js –out es5.js –experimental Some commands let 块级作用域 不存在变量提升 暂时性死区[在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）] 不允许重复声明 块级作用域外部，无法调用块级作用域内部定义的函数 const 声明后不可变 同样是块级作用域，不提升，有暂时性死区，不可重复声明 const命令只是指向变量所在的地址，所以将一个对象声明为常量必须非常小心，因为可以改变其属性 对对象冻结：Object.freeze ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。 跨模块常量：12345export XXX-----import * as XXX from XXX-----import &#123;XXX&#125; from XXX 变量的解构赋值 如果解构不成功，变量的值就等于undefined 解构赋值允许指定默认值 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错,解构不仅可以用于数组，还可以用于对象 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值 不能使用圆括号的情况 变量声明语句中，模式不能带有圆括号 函数参数中，模式不能带有圆括号 不能将整个模式，或嵌套模式中的一层，放在圆括号之中 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号 Iterator Waiting","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"leetcode-JavaScript实现","date":"2015-10-11T10:22:00.000Z","path":"2015/10/11/leetcode/","text":"找工作找的心伤，碰上今年这个动荡的互联网就业年份，刷题安抚下情绪＝＝,然后发现n久之前刷过的几道都过期了，看不到当时的解决了……算了，这次还是存个档吧。Add Two Numbers https://leetcode.com/problems/add-two-numbers/ You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; var resultNode = new ListNode(0); var result = resultNode; var sum = 0; if(l1===null&amp;&amp;l2===null)&#123; return null; &#125; while(l1!==null||l2!==null)&#123; if(l1!==null)&#123; sum = sum+l1.val; l1 = l1.next; &#125; if(l2!==null)&#123; sum = sum+l2.val; l2 = l2.next; &#125; if(sum&gt;9)&#123; result.val = sum-10; result.next = new ListNode(1); result = result.next; sum = 1; &#125; else&#123; result.val = sum; if(l1!==null||l2!==null)&#123; result.next = new ListNode(0); result = result.next; sum = 0; &#125; &#125; &#125; return resultNode;&#125;; Longest Substring Without Repeating Characters： https://leetcode.com/problems/longest-substring-without-repeating-characters/ Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1. 1234567891011121314151617181920212223/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; var item = \"\"; var num=0; for(var i=0;i&lt;s.length;i++)&#123; if(item.indexOf(s[i])===-1)&#123; item = item + s[i]; var len = item.length; if (len&gt;num)&#123; num = len; &#125; &#125; else&#123; var index = item.indexOf(s[i]); item = item.substr(index+1); item = item+s[i]; &#125; &#125; return num;&#125;; ZigZag Conversion https://leetcode.com/problems/zigzag-conversion/ 简单的说就是从左边开始不停画Z字型路线，然后从上部读取字母拼成输出。 后来网上找了下，这个孩子的分析思路和我的基本一样。 1234567891011121314151617181920212223/** * @param &#123;string&#125; s * @param &#123;number&#125; numRows * @return &#123;string&#125; */var convert = function(s, numRows) &#123; if(s===\"\"||numRows&lt;1||s===null)&#123;return \"\"&#125; if(numRows===1)&#123;return s&#125; if(s.length&lt;=numRows)&#123;return s&#125; var step = 2*numRows - 2; var output=\"\"; for(var i=0; i&lt;numRows; i++ )&#123; for(var j=i; j&lt;s.length; j=j+step)&#123; output += s[j]; if(i!==0&amp;&amp;i!==(numRows-1))&#123; var minStep = step - i*2; if((j+minStep)&lt;s.length)&#123; output += s[j+minStep];&#125; &#125; &#125; &#125; return output;&#125;; Reverse Integer https://leetcode.com/problems/reverse-integer/ Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 12345678910111213141516171819202122/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123; var flag = false if(x&lt;0)&#123; flag = true; &#125; x = Math.abs(x); var str = x+ \"\"; var out = \"\" for(var i=0;i&lt;str.length;i++)&#123; out += str[str.length-i-1]; &#125; out = parseInt(out); if(out &gt; Number.parseInt(\"1111111111111111111111111111111\", 2))&#123;return 0&#125; if(flag)&#123; out = -out; &#125; return out;&#125;; String to Integer (atoi) https://leetcode.com/problems/string-to-integer-atoi/ Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;string&#125; str * @return &#123;number&#125; */var myAtoi = function(str) &#123; if(str.length === 0)&#123;return 0;&#125; var count = 0; var flag = false; str = str.trim(); if(str[0]===\"+\"||str[0]===\"-\")&#123; flag = true; if(isNaN(parseInt(str[1])))&#123; return 0; &#125; &#125; if(flag)&#123; for(var i=1 ; i&lt;str.length;i++)&#123; if(isNaN(parseInt(str[i])))&#123; str = str.substr(0,i); &#125; &#125; &#125; else&#123; for(var j=0 ; j&lt;str.length;j++)&#123; if(isNaN(parseInt(str[j]))&amp;&amp;j!==0)&#123; str = str.substr(0,j); &#125; else if(isNaN(parseInt(str[j]))&amp;&amp;j===0)&#123; return 0; &#125; &#125; &#125; if(parseInt(str)&lt;-2147483648) &#123;return -2147483648;&#125; if(parseInt(str)&gt; 2147483647) &#123;return 2147483647;&#125; return parseInt(str);&#125;; Palindrome Number https://leetcode.com/problems/palindrome-number/ Determine whether an integer is a palindrome. Do this without extra space. 12345678910111213141516171819202122232425262728/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */var isPalindrome = function(x) &#123; if(x&lt;0)&#123; return false; &#125; var str = x + \"\"; if(str.length===1)&#123; return true; &#125; if(str.length%2===0)&#123; for(var i=0; i&lt;(str.length/2); i++)&#123; if(str[i]!==str[str.length-1-i])&#123; return false; &#125; &#125; &#125; else&#123; for(var j=0; j&lt;((str.length+1)/2)-1;j++)&#123; if(str[j]!==str[str.length-j-1])&#123; return false; &#125; &#125; &#125; return true;&#125;; Roman to Integer https://leetcode.com/problems/roman-to-integer/ Given a roman numeral, convert it to an integer.Input is guaranteed to be within the range from 1 to 3999. 题目没写具体的罗马数规律，查了一下，如下：罗马数规律 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function(s) &#123; var num = []; for(var i=0; i&lt;s.length; i++)&#123; switch(s[i])&#123; case \"I\": num.push(1); break; case \"V\": num.push(5); break; case \"X\": num.push(10); break; case \"L\": num.push(50); break; case \"C\": num.push(100); break; case \"D\": num.push(500); break; case \"M\": num.push(1000); break; &#125; &#125; if(num.length===0)&#123;return 0;&#125; if(num.length===1)&#123;return num[0];&#125; var sum = num[0]; for(var j=1 ;j&lt;num.length;j++)&#123; if(num[j]&lt;=num[j-1])&#123; sum += num[j]; &#125; else&#123; sum = sum - 2*num[j-1] + num[j]; &#125; &#125; return sum;&#125;; Longest Common Prefix https://leetcode.com/problems/longest-common-prefix/ Write a function to find the longest common prefix string amongst an array of strings. 1234567891011121314151617181920212223/** * @param &#123;string[]&#125; strs * @return &#123;string&#125; */var longestCommonPrefix = function(strs) &#123; if(strs.length===0)&#123;return \"\";&#125; var short=strs[0].length; for(var i=0;i&lt;strs.length;i++)&#123; if(strs[i].length&lt;short)&#123; short = strs[i].length; &#125; &#125; var pre = \"\"; for(var j=0;j&lt;short;j++)&#123; for(var k=1;k&lt;strs.length;k++)&#123; if(strs[k][j]!==strs[k-1][j])&#123; return pre; &#125; &#125; pre = pre + strs[0][j]; &#125; return pre;&#125;;","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"算法","slug":"算法","permalink":"http://memory.lulutia.com/tags/算法/"}]},{"title":"留档：Node学习脚印一","date":"2015-10-11T10:21:00.000Z","path":"2015/10/11/Node1/","text":"资料准备部分 Node入门 深入浅出Node.js Node入门部分目标： 用户通过浏览器使用此应用。 当用户请求http://domain/start时，可以看到一个欢迎页面，页面上有一个文件上传的表单。 用户可以选择一个图片并提交表单，随后文件将被上传到http://domain/upload，该页面完成上传后会把图片显示在页面上。 模块分析： Web页面：HTTP服务器 不同的URL：路由 请求处理程序 上传数据 保存展示数据 123456789101112//index.jsvar server = require(\"./server\");var router = require(\"./router\");var requestHandlers = require(\"./requestHandlers\");var handle = &#123;&#125;;handle[\"/\"] = requestHandlers.start;handle[\"/start\"] = requestHandlers.start;handle[\"/upload\"] = requestHandlers.upload;handle[\"/show\"] = requestHandlers.show;server.start(router.router, handle); 12345678910111213141516//server.jsvar http = require(\"http\");var url = require(\"url\");var server = &#123;&#125;;server.start = function(router, handle)&#123; http.createServer(function(req,res)&#123; var pathname = url.parse(req.url).pathname; console.log(\"Request for \" + pathname + \" received\"); router(handle, pathname, res, req); &#125;).listen(8124); console.log(\"Server running at http://127.0.0.1:8124/\");&#125;module.exports = server; 12345678910111213141516//router.jsvar router = &#123;&#125;;router.router = function(handle, pathname, res, req)&#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === \"function\")&#123; handle[pathname](res, req); &#125; else&#123; console.log(\"no router \" + pathname); res.writeHead(404, &#123;\"Content-Type\": \"text/plain\"&#125;); res.write(\"404 Not found\"); res.end(); &#125;&#125;module.exports = router; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//requestHandlers.jsvar querystring = require(\"querystring\");var fs = require(\"fs\");var formidable = require(\"formidable\");var requestHandlers = &#123;&#125;;requestHandlers.start = function(res, req)&#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" '+ 'content=\"text/html; charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '+ 'method=\"post\"&gt;'+ '&lt;input type=\"file\" name=\"upload\"&gt;'+ '&lt;input type=\"submit\" value=\"Upload file\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; res.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); res.write(body); res.end();&#125;requestHandlers.upload = function(res, req)&#123; console.log(\"upload\"); var form = new formidable.IncomingForm(); form.parse(req, function(error, fields, files)&#123; console.log(\"parsing done\"); fs.renameSync(files.upload.path, \"/tmp/test.png\"); res.writeHead(\"200\", &#123;\"Content-Type\": \"text/html\"&#125;); res.write(\"received image:&lt;br/&gt;\"); res.write(\"&lt;img src='/show' /&gt;\"); res.end(); &#125;)&#125;requestHandlers.show = function(res, postData)&#123; console.log(\"SHOW\"); fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file)&#123; if(error)&#123; res.writeHead(500, &#123;\"Content-Type\": \"text/plain\"&#125;); res.write(error + \"\\n\"); res.end(); &#125; else&#123; res.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); res.write(file, \"binary\"); res.end(); &#125; &#125;)&#125;module.exports = requestHandlers; 注意点 阻塞和非阻塞的问题","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"留档：GitHub＋hexo＋godaddy","date":"2015-09-11T11:22:00.000Z","path":"2015/09/11/hello-world/","text":"环境准备部分 安装Node，去node官网根据自己的机子选择合适的一路傻瓜安装就行了，node安装好了一般npm也集成在里面了。 安装git，我用的是git的客户端SourceTree，选择很多，怎样顺手怎样来。 github部分github是一个开源代码库以及版本控制系统。 申请一个GitHub的账号，路径点击上面链接。 建立项目的仓库，这里根据你希望搭建的博客形式分为了两种方式： 个人或者组织的，这种情况下，你建立的仓库必须与你的用户名保持一致。比如：atmos/atmos.github.io。而且在这个仓库下的master分支将作为内容被建立并且发布到GitHub Pages site。 项目的主页。在这种情况下，可以针对每个具体的项目仓库创建其相对的主页，分支gh-pages作为内容来建立和发布内容。它的访问url一般为username(orgname).github.io/projectname。 总结：如果是希望建立全局性(内容上)的网页建议用第一种方式，否则用第二种方式。详细对比可见GitHub Help。 添加SSH公匙到Account settings －》SSH Keys －》Add SSH Key(其实如果不用SSH连接是可以省略这一步的)，具体过程点击我。将的很详细，跟着走就可以了。 将此仓库克隆到本地(此处需要建立没有历史纪录和操作记录的新分支，所以最好新克隆)，然后创建gh-pages的分支并且将里面的内容都删除，此处不要提交修改。具体过程点击我。 hexo部分hexo是一个快速，简洁高效的博客框架。 在命令行里输入npm install hexo-cli -g进行安装。这里可能会出现几个问题。 需要权限，此时输入变为sudo npm install hexo-cli -g即可。 卡node-gyp rebuild的问题，比如以下错误: 123456789101112node-gyp rebuildgyp WARN install got an error, rolling back installgyp ERR! configure error gyp ERR! stack Error: EPERM, utime '/Users/dirk/.node-gyp/0.12.4'gyp ERR! stack at Error (native)gyp ERR! System Darwin 14.3.0gyp ERR! command \"node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"gyp ERR! cwd /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-fs/node_modules/chokidar/node_modules/fseventsgyp ERR! node -v v0.12.4gyp ERR! node-gyp -v v1.0.3gyp ERR! not ok npm WARN optional dep failed, continuing fsevents@0.3.6 原因就是GFW啦，所以要使用下国内镜像然后安装，如下： 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org #可能需要sudo$ cnpm install hexo-cli -g 接着执行以下代码，主要就是初始化blog，如果没有指定文件夹则默认就在当下文件夹，然后切换到初始化后的文件夹安装依赖，最后开启本地服务器，此时访问本地http://localhost:4000/就可以了，命令如下： 123hexo init blogcd blognpm install 但是在实际执行中可能会遇见一些问题，比如： 12345[Error: Module did not self-register.]&#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;ERROR Plugin load failed: hexo-generator-feedReferenceError: hexo is not defined 解决方案： 12npm install hexo-generator-feed --savenpm install hexo --save 以上只是部署到了本地，实际上我们需要部署到github上，所以需要去修改hexo的配置，主要修改deploy部分，修改如下,注意type不能写github： 1234deploy: type: git repository: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: gh-pages 然后执行以下命令： 12hexo ghexo deploy 实际中可能遇见的问题，比如： 123&#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; 解决方案： 1npm install hexo-deployer-git --save 主题安装主题寻找地址安装方法也很简单，具体的每个主题下有，大概就是将他们克隆到本地的themes文件夹下，然后修改hexo的配置里的theme为希望的主题。 域名部署 我是之前在godaddy上买过一个域名。 Godaddy注册商域名修改DNS地址。 在DNSPod添加域名后进入控制台添加纪录，这边已经有两条记录了，此时再添加两条，一条是A纪录的host为@指向github的ip，这里是固定的192.30.252.153。另外一条CNAME纪录的host为www指向你的主页.github.io(当然这里也可以通过dig命令获取具体的ip值)，同理，如果是项目主页可以添加二级目录指向.github.io。 在具体的项目下添加一个文件CNAME。里面写上你希望对应的域名，然后提交。接着生成部署hexo就行。 更加详细内容参照。 另外一些参考资料 资料一 资料二","tags":[{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://memory.lulutia.com/tags/环境搭建/"}]}]