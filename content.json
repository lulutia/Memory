[{"title":"移动端基于vue-router的滚动位置记录(keep-alive)","date":"2018-01-19T02:57:00.000Z","path":"2018/01/19/keep-alive/","text":"本文主要对于如何在基于vue的移动端实现滚动位置记录进行了探讨。 在日常开发中，我们经常的会遇见与滚动位置记录相关的需求。多见于从列表页进入详情页，然后进行回退。对这种情况提炼出一套解决方案是相当有必要的。 背景在日常开发中，我们经常的会遇见与滚动位置记录相关的需求。多见于从列表页进入详情页，然后进行回退。原因如下： 在移动开发中，列表多是由无限滚动进行加载的，因此如果回退后又从头进行加载实际上用户体验是相当不好的 如果列表页的展现对实时性要求不高甚至长期不变，则回退后又进行的重新加载实际上是性能的浪费 针对上面，在实际操作时更理想的情况是，对于实时性不高的列表，从列表页进入详情页又回退后，列表页会保存之前的位置。在基于vue-router的项目中，为了实现上述效果可以使用其提供的keep-alive功能与scrollBehavior进行配合。 keep-alive与scrollBehavior keep-alive: keep-alive是Vue内置的一个抽象组件，它自身不会渲染DOM元素也不会出现在父组件链中，它只是在包裹动态组件时会缓存不活动的组件实例，而不是销毁它们。更多使用方法详见Vue官方文档。 scrollBehavior: scrollBehavior是由vue-router中Router实例提供的方法，它接受三个参数，分别为(to, from, savedPosition)，其中to和from是路由对象，而savedPosition是当 popstate导航(通过浏览器的 前进/后退 按钮触发)时记录的位置信息。 scrollBehavior返回滚动位置的对象信息，如{ x: number, y: number}，如果返回的是falsy或者空对象则不会发生滚动。 注意scrollBehavior只在HTML5 history模式下可用。 实际使用 使用router-view配合keep-alive: 在入口文件通过v-if进行对特定页面的缓存。 123456&lt;div class=\"page-group\"&gt; &lt;keep-alive&gt; &lt;router-view class=\"view\" v-if=\"$route.meta.keep_alive\"&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view class=\"view\" v-if=\"!$route.meta.keep_alive\"&gt;&lt;/router-view&gt;&lt;/div&gt; 对路由进行配置，开启HTML5 history模式并配置scrollBehavior： 12345const router = new VueRouter(&#123; mode: 'history', scrollBehavior: scrollBehavior, routes&#125;); 对路由进行配置，定制scrollBehavior方法，在这里会遇见以下几个问题： 如何判断页面是否需要保留位置信息: 123456789101112export default &#123; name: constants.NAME, path: constants.PATH, component: module, meta: &#123; title: constants.TITLE, val_cid: constants.VAL_CID, requireAuth: constants.REQUIRE_AUTH, keep_alive: true &#125;, constants&#125;; 我们通过在路由上添加了一个参数keep_alive来声明当前路由是否要启动keep_alive的功能。 如何根据需要刷新页面，重新获取数据: 假如我们有三个页面，通过A进入B，通过B进入C。那么其中通过A进入B是需要进行数据刷新的；而从B进入C，再从C返回B则不需要进行数据刷新。因此针对同一个页面我们需要使用一种机制来判断多久需要数据刷新。基本我们可以提炼出：通过跳转的是需要进行数据刷新的；而通过默认浏览器行为的是不需要进行浏览器刷新的。看vue-router的源码中我们会发现下面的代码： 12345678window.addEventListener('popstate', e =&gt; &#123; ....... this.transitionTo(location, route =&gt; &#123; if (supportsScroll) &#123; handleScroll(router, route, current, true) &#125; &#125;) &#125;) 12345678push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; ... this.transitionTo(location, route =&gt; &#123; ... handleScroll(this.router, route, fromRoute, false) ... &#125;, onAbort)&#125; 上面代码在处理popstate时调用的handleScroll方法传入的最后一个参数是true，但是自己重写的push、replace等函数调用handleScroll时传入的最后一个参数都是false。而在scroll.js中，我们可以看到handleScroll函数的最后一个参数就是用来区分浏览器默认行为，和router-link的行为的。 123456789......const behavior = router.options.scrollBehavior......router.app.$nextTick(() =&gt; &#123; const position = getScrollPosition() const shouldScroll = behavior.call(router, to, from, isPop ? position : null)...... &#125;)&#125; 在上面一段代码中，我们可以看到，对于浏览器默认行为，调用自定义的scrollBehavior函数后传参的savedPosition为保存的position，对于跳转这种则传参的savedPosition为null。通过上面，我们已经能区分什么时候需要进行数据刷新了。之后，我们需要修改两部分的代码，一部分是scrollBehavior，修改它来根据不同的情况返回不同的滚动值；另外一部分是实际keep-alive的页面的渲染逻辑，它需要根据不同的情况来选择是否进行数据获取。 1234567const scrollBehavior = (to, from, savedPosition) =&gt; &#123; if (to.matched.some(t =&gt; t.meta.keep_alive)) &#123; to.meta.saved_position = savedPosition; // 传递这个值到具体页面来判断是否进行数据刷新 let back = savedPosition ? savedPosition : &#123;x: 0, y: 0&#125;; return back; &#125;&#125;; 12345678beforeRouteEnter: function(to ,from, next)&#123; next(vm =&gt; &#123; // 通过对null的判断决定是否进行数据刷新 if (to.meta.saved_position === null) &#123; vm.initAll(); &#125; &#125;) &#125; 这里需要注意必须要在beforeRouteEnter的next里面进行调用，因为一般的生命周期钩子比如mounted等都会被keep-alive给吃掉。 需要注意的点在实际使用中，其实上面这种做法会有问题。我们会发现，在A页面进行刷新，然后第一次从A进入B，又从B返回A的时候，并没有滚动到特定的位置。它滚动到了顶部。通过代码调试，我们可以看到，这一次返回的savedPosition为undefined，因此在判断back的时候会赋值{x: 0, y: 0}。 为了解决这个问题，我们需要手动记录一下滚动的位置。 在路由跳转的时候，如果from的是keep-alive的页面，则记录它的位置，并保存在路由上。之后通过浏览器行为进入这个页面的时候对位置进行判定，如果有就取这个值。 1234567891011const scrollBehavior = (to, from, savedPosition) =&gt; &#123; if (to.matched.some(t =&gt; t.meta.keep_alive)) &#123; if (savedPosition === null) &#123; to.meta.saved_position = null; &#125; else &#123; savedPosition = to.meta.saved_position; &#125; let back = savedPosition ? savedPosition : &#123;x: 0, y: 0&#125;; return back; &#125;&#125;; 1234567router.beforeEach((to, from, next) =&gt; &#123; ... if (from.meta.keep_alive) &#123; from.meta.saved_position = &#123;x: window.pageXOffset, y: window.pageXOffset&#125;; &#125; ...&#125;) 自此，可以解决这个问题。那么我们接下来看下，为啥会出现undefined。在vue-router的代码中，有下面几段： 123456789101112 router.app.$nextTick(() =&gt; &#123; const position = getScrollPosition() const shouldScroll = behavior.call(router, to, from, isPop ? position : null)...... &#125;) function getScrollPosition (): ?Object &#123; const key = getStateKey() if (key) &#123; return positionStore[key] &#125;&#125; 我们可以看到，如果在调用getScrollPosition方法时，如果在positionStore里面没有找到对应当前key的数据，则会返回undefined。 那么为什么会没找到当前的key呢，因为刷新后，也就是当router进行初始化时，当前的路由状态并没有在history上进行注册，即window.history.state为null。此时，当在当前页面A进行滑动后跳转到其他页面B时，会将位置信息存储到positionStore上面，key为初始化的window.performance.now().toFixed(3)。此时，点击回退按钮，会触发popstate来获取A的信息。但是因为A的history state并没有注册。所以无法找到匹配的位置信息。 不过好的是现在这个问题已经被修复了，在2.8.0及其以上版本中可以看到。修复思路就是在路由进行初始化的时候调用window.history.replaceState({ key: getStateKey() }, ‘’)来进行一个注册。具体见链接 参考 vue-router 中使用 keep-alive 控制 ajax 请求的缓存策略(二) vue-router dev分支源码 scrollBehavior doesn’t store a scrolling position on the first page #772 scrollBehavior doesn’t work for initial route in Firefox #1585","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"vue","slug":"vue","permalink":"http://memory.lulutia.com/tags/vue/"}]},{"title":"Vue生命周期总结","date":"2017-10-31T07:04:00.000Z","path":"2017/10/31/vuetimeline/","text":"本文主要总结了vue中涉及到的生命周期，并且通过实际尝试得出了其执行顺序。 在进行Vue项目开发的过程中，会不可避免的接触它的生命周期。了解每个生命周期的特性及其使用场景对于快速进行项目开发相当重要。 全局守卫一般基于Vue全家桶进行开发的项目都会采用vue-router来进行路由处理。在这种情况下，全局路由钩子将会是我们接触的生命周期第一站。这块主要涉及到以下两个方法： 使用router.beforeEach注册一个全局前置守卫。直白的说就是当一个导航触发时，会按照顺序执行完毕此方法里的内容后再进行跳转[resolve后]。因此，在这个周期内特别适合做全局拦截，比如判断登陆状态。这个方法接受三个参数(from, to, next)，并且以调用next方法来作为resolve的标志。next方法可以传入以下几种参数： 不传参数如next()：进行管道中的下一个钩子，执行完后成为resolve状态，进行正常跳转 传入具体的路径如next(‘/‘): 直接跳转到传入的地址，当前导航会被中断，进行新的导航 传入false如next(false): 中断当前导航，保持在当前的页面 传入error如next(error): error是一个Error实例，导航会被终止且该错误会被传递给router.onError()注册过的回调 1234router.beforeEach((to, from, next) =&gt; &#123; console.log('router.beforeEach') next()&#125;) 使用router.afterEach注册一个全局后置钩子，接受两个参数(from, to)。不接受next，也不改变导航状态 123router.afterEach((to, from, next) =&gt; &#123; console.log('router.afterEach')&#125;) 根组件按照正常思维来思考，当路由确定后就涉及到具体页面的渲染。因此这部分涉及到以下几个实例的生命周期： beforeCreate：这个阶段主要执行初始化。可以访问实例本身，但是因为实例的配置还没完成，因此访问data或者method都是没用的。 created：这个阶段已经进行了实例的配置，因此可以访问data、method和computed等了。但是因为挂载还没完成，所以直接访问this.$el是没用的 beforeMount：这个阶段是在挂载开始之前执行，之后就会走正常的渲染逻辑 mounted：在这个阶段挂载已经完成，所以访问this.$el已经能够拿到元素了 beforeDestroy：这个阶段在实例销毁之前调用，因为是之前，所以在这个阶段还能够访问实例本身 destroyed：这个阶段表示实例已经被销毁完成了。因此所有自己本身及其子组件的绑定，监听都会销毁 上面是一个最基本的流程。加上前面的全局路由。我们可以看见其执行先后顺序如下： 通过上面的展示，我们得到注意点，在从A页面跳转到B页面时，A页面的beforeDestroy和destroyed方法是比全局路由的beforeEach和afterEach执行的晚的。 除了上面一个最基本的流程外，还有一个很重要的环节就是更新。关于这个，有下面两个生命周期阶段： beforeUpdate：数据更新时调用，发生在virtual dom进行对比和渲染之前。因此在这个阶段继续更改数据不会触发重新的渲染。但是这里有几个需要注意的地方如下： 如果只是单纯的数据变化，而这个变化并没有在template里面使用，则这个函数也不会触发。 在beforeUpdate里面进行的数据更新，如果与之前的一样，则virtual dom对比结果为一样，此时不会重新触发beforeUpdate和updated；如果不一样，则会触发beforeUpdate和updated，但实际updated时更新的数据为后面的，证明在这个阶段继续更改数据不会触发重新的渲染；但是如果这个阶段的数据更新是异步的，比如延迟一秒更新，实际updated会触发两次并且数据不一样，表明触发了新的绘制 在beforeUpdate里面重复修改同一个数据可能导致beforeUpdate函数的无限循环，应尽量避免 updated：virtual dom重新渲染和打补丁之后调用。所以如果在这个阶段再进行数据的更改会又重新触发beforeUpdate，恰巧如果beforeUpdate里面有同一数据的修改则很容易导致无限循环，所以最好避免这种事情发生。这个环节后，可以使用更新后的dom。 在添加了上面两个方法后，现在我们可以看其执行顺序如下： 子组件根组件的基本生命周期探讨到一阶段了，因为现在都是组件化的思维，因此现在很自然的就会想到子组件的生命周期在全局是处于何种位置的。与根组件一样，子组件也拥有beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed这几个生命阶段。现在我们来看在不执行更新操作时的执行顺序： 由上可知: 子组件的初始化晚于根组件，但是其挂载早于根组件，即当子组件都mounted后，根组件才会mounted。具体子组件的beforeCreated时间是在根组件的beforeMount之后 子组件的销毁开始时间也晚于根组件，但是只有当子组件都destroyed后，根组件才destroyed了 那加上更新操作时会怎样呢？我们构造了一个子组件，将根组件的msg作为props传入进去，然后根据这个prop构造一个计算属性，来作为子组件的template中的一个参数。注意这里一定要使用计算属性，如果直接使用data的话，是不会更新的： 12345678910111213141516171819&lt;smallcomponent :msg=\"msg\"/&gt;..........HelloWorld.vue......... &lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;componentInfo&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;... props: &#123; msg: &#123; type: String &#125; &#125;, computed: &#123; componentInfo () &#123; return this.msg &#125; &#125;,..........Time.vue........ 在上面这种情况下，我们可以得出其生命周期如下，很明显，根组件是在子组件更新完毕后才更新完毕的： 指令除了上面所说的子组件，根组件里面可能还会有指令存在，总的来说指令也会有其对应的生命周期，如下来自vue官方文档： bind：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作 inserted：被绑定元素插入父节点时调用 (父节点存在即可调用，不必存在于 document 中) update：所在组件的VNode更新时调用，但是可能发生在其孩子的VNode更新之前 componentUpdated：所在组件的VNode及其孩子的VNode全部更新时调用 unbind：只调用一次，指令与元素解绑时调用 我们实现了一个指令，将根组件的msg作为值传入指令中，在最基本的状态下，他们的生命周期流程如下： 看来指令和子组件的状态十分类似，也是在根组件beforeMount后进行bind与inserted，然后根组件才执行mounted；在解绑时，也是在根组件beforeDestroy后执行，执行完后根组件才可能执行destroyed 同样，如果这时，加上更新操作，其生命流程会如下所示，很明显，根组件是在指令更新完毕后才更新完毕的： 之前我们单独的讨论了子组件和指令，那么如果它们在一起时生命周期的顺序又是怎样呢？通过实际实验，我们得出其顺序如下，当我们在根组件里先引入子组件再引入指令时其顺序如下左图，当我们先引人指令再引人子组件时其顺序如下右图： 很明显，这个顺序是和引人组件或者指令的先后顺序有关～ 销毁阶段谁先引入谁先销毁 更新阶段，都是指令的更新靠前 创建阶段，谁先引入谁先进行初始化，但总的来说挂载都在初始化之后[无论谁的初始化] 组件内的守卫在前面我们已经讨论过全局守卫、根组件、子组件和指令了。但实际上对于组件而言，它还存在组件内的守卫，如下： beforeRouteEnter：在渲染该组件的对应路由被 confirm 前调用，不能获取组件实例 this，因为当守卫执行前，组件实例还没被创建 beforeRouteUpdate：在当前路由改变，但是该组件被复用时调用，可以访问组件实例this beforeRouteLeave：导航离开该组件的对应路由时调用，可以访问组件实例this 我们在根组件添加了以上几个方法，可以看见整个生命周期如下所示： 由上可知，beforeRouteEnter是在全局守卫之后调用，而beforeRouteLeave是在全局守卫之前调用。上面我们说到在beforeRouteEnter阶段是没法访问到this的，为了解决这个问题，可以通过传一个回调给next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 123456beforeRouteEnter (to, from, next) &#123; console.log('beforeRouteEnter') next(vm =&gt; &#123; console.log('beforeRouteEnter的next') &#125;) &#125;, 那么这个的触发又是在生命周期的那一环呢？ 很明显它会在完成mounted后马上触发。所以虽然beforeRouteEnter的执行时间很早，但是它的回调执行的时间比较晚，算是最接近dom渲染的一个周期了 路由独享的守卫除了上面我们讨论的全局守卫和组件内的守卫，实际还有一个路由独享的守卫，即可以在路由配置上直接定义beforeEnter守卫。具体使用如下： 123456789101112131415161718const router = new Router(&#123; routes: [ &#123; path: '/', name: 'Hello', component: HelloWorld, beforeEnter: (to, from, next) =&gt; &#123; console.log('Exclusive beforeEnter') next() &#125; &#125;, &#123; path: '/world', name: 'World', component: Page2 &#125; ]&#125;) 通过实际情况我们可以得知，这个方法的调用会在全局守卫的beforeEach之后，而在组件内守卫的beforeRouteEnter之前，如下： Vue.nextTick &amp; vm.$nextTick除了上面讨论的，还有两个和生命周期有关系的方法，如下： Vue.nextTick：这是个全局API，在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM vm.$nextTick: 将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法Vue.nextTick一样，不同的是回调的this自动绑定到调用它的实例上 我们将这部分加上去，得到整个这篇文章探讨的生命周期过程如下： 参考 Vue.js官方文档 vue-router官方文档 vue生命周期探究（一）","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"vue","slug":"vue","permalink":"http://memory.lulutia.com/tags/vue/"}]},{"title":"基于IntersectionObserver的曝光统计测试","date":"2017-10-18T09:23:00.000Z","path":"2017/10/18/IntersectionObserve/","text":"本文主要介绍了IntersectionObserver API，并且就如何将其用于数据埋点给出了尝试。 背景介绍 作为一款产品，往往希望能得到用户的反馈，从而通过对用户行为的分析进行功能、交互等方方面面的改进。然而直接的一对一的用户交流是低效且困难的，因此最普遍的做法便是通过数据埋点来反推用户的行为。那么数据埋点中很重要的一环便是：曝光。 所谓曝光，便是页面被展示的时候进行打点。举个简单的例子：用户进入分类页面，商品以行为单位从上而下进行排列。当用户滚动页面时，之前不在视窗范围内的商品就会出现，此时，这部分商品就算曝光了。需要进行一次记录。 那么为了实现上面功能，最普遍的做法有两个。其一：跟踪滚动事件，然后计算某个商品与视窗的相对位置，从而判断是否可见。其二：维持一个timer，然后以固定的时间为间隔计算某个商品与视窗的相对位置。 上面两种做法在某种程度上能够实现我们的目的，但是会有一些问题，比如最明显的：慢。因为计算相对位置时会调用getBoundingClientRect()，这个操作会导致浏览器进行全页面的重新布局，不用我说，大家都知道这个性能开销是很大的，特别是在频繁进行时。除此之外，如果页面是作为一个iframe包裹的也会产生问题，因为同源策略和浏览器不会允许你获取包裹iframe的页面的数据。然而在现有情况下，很多广告都是通过iframe的形式镶嵌在网页内的。 基于以上的情况，我们急需一种性能良好且iframe友好的方式来实现曝光的功能，因此IntersectionObserver API进入了我们的视野。 IntersectionObserver API介绍关于IntersectionObserver API的官方文档见此。截止本文为止，其兼容性如下图所示:简单的说IntersectionObserver让你知道什么时候observe的元素进入或者存在在root区域里了。下面我们来看下这个API的具体内容: 12345678910111213141516171819202122232425262728293031// 用构造函数生成观察者实例，回调函数是必须的，后面的配置对象是可选的var observer = new IntersectionObserver(changes =&gt; &#123; for (const change of changes) &#123; console.log(change.time); // 相交发生时经过的时间 console.log(change.rootBounds); // 表示发生相交时根元素可见区域的矩形信息，是一个对象值 console.log(change.boundingClientRect); // target.boundingClientRect()发生相交时目标元素的矩形信息，也是个对象值 console.log(change.intersectionRect); // 根元素与目标元素相交时的矩形信息 console.log(change.intersectionRatio); // 表示相交区域占目标区域的百分比，是一个0到1的值 console.log(change.target); // 相交发生时的目标元素 &#125;&#125;, &#123; root: null, threshold: [0, 0.5, 1], rootMargin: \"50px\"&#125;);// 实例属性observer.rootobserver.rootMarginobserver.thresholds// 实例方法observer.observe(target); // 观察针对某个特定元素的相交事件observer.unobserve(target); // 停止对某个特定元素的相交事件的观察observer.disconnect(); // 停止对所有目标元素的阈值事件的观察，简单的说就是停用整个IntersectionObserver// 除了上面三个实例方法，还有一个takeRecords()的方法，之后会详细介绍 IntersectionObserver API允许开发人员了解目标dom元素相对于intersection root的可见性。这个root可以通过实例属性获取。默认情况下它为null，此时它不是真正意义上的元素，它指视窗范围，因此只要视窗范围内的目标元素(当然是后代元素)滚入视窗时，就会触发回调函数[如果root元素不存在了，则执行其任何的observe都会出错]。下面举个栗子: 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;intersectionObserve&lt;/title&gt; &lt;style type=\"text/css\"&gt; #target &#123; position: relative; top: calc(100vh + 500px); width: 100px; height: 100px; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"target\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; let ele = new IntersectionObserver( (entries) =&gt; &#123; console.log(entries); &#125; ); ele.observe(target); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面的栗子中，当红色的块滚入滚出视窗，都会触发回调函数，回调函数在调用时会传入一个由IntersectionObserverEntry 对象组成的数组。每个IntersectionObserverEntry 对象包含对应的observed元素的更新信息，大概数据结构如下，其具体意思在第一段代码里有详细说明:我们可以在配置对象中将root改为具体的元素，此时当目标元素出现在root元素中时会触发回调，注意，在这种情况下相交可能发生在视窗下面。具体代码在下，感兴趣的孩子可以试一下: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;intersectionObserve&lt;/title&gt; &lt;style type=\"text/css\"&gt; #root &#123; position: relative; width: 400px; height: calc(100vh + 200px); background: lightblue; overflow: scroll; &#125; #target &#123; position: absolute; top: calc(100vh + 800px); width: 100px; height: 100px; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt; &lt;div id=\"target\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; let ele = new IntersectionObserver( (entries) =&gt; &#123; console.log(entries); &#125;, &#123; root: root &#125; ); ele.observe(target); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在上面一条中，回调函数打印出来的对象中有一个intersectionRatio值，这个值其实涉及到了整个API的核心功能：当目标元素和根元素相交的面积占目标元素面积的百分比到达或跨过某些指定的临界值时就会触发回调函数。因此相对的在配置对象里有一个threshold来对这个百分比进行配置，默认情况下这个值是[0]，注意里面的值不能在0-1之外，否则会报错。我们举个栗子如下: 12345678910......let ele = new IntersectionObserver( (entries) =&gt; &#123; console.log(entries); &#125;, &#123; threshold: [0, 0.5, 1.0] &#125;);ele.observe(target); 在上面这个栗子中，我们设定了0，0.5，1.0这三个值，因此当交叉区域跨越0，0.5，1.0时都会触发回调函数。注意我这边的用词是跨越，而不是到达。因为会存在以下两种情况导致回调打印出来的intersectionRatio不为0，0.5和1.0.其一： 浏览器对相交的检测是有时间间隔的。浏览器的渲染工作都是以帧为单位的，而IntersectionObserver是发生在帧里面的。因此假如你设定了[0,0.1,0.2,0.3,0.4,0.5]这个threshold，但是你的滚动过程特别快，导致所有的绘制在一帧里面结束了，此时回调只会挑最近的临界值触发一次。其二： IntersectionObserver是异步的。在浏览器内部，当一个观察者实例观察到众多的相交行为时，它不会立即执行。关于IntersectionObserver的草案里面写明了其实现是基于requestIdleCallback()来异步的执行我们的回调函数的，并且规定了最大的延迟时间是100ms。关于这部分涉及到前面第一段代码里的一个实例方法takeRecords()。如果你很迫切的希望马上知道是否有相交，你不希望等待可能的100ms，此时你就能调用takeRecords()，此后你能马上获得包含IntersectionObserverEntry 对象的数组，里面有相交信息，如果没有任何相交行为发生，则返回一个空数组。但这个方法与正常的异步回调是互斥的，如果它先执行了则正常回调里面就没信息了，反之亦然。除开上面的问题，如果目标元素的面积为0会产生什么情况呢？因为与0计算相交率是没有意义的，实际我们举个栗子： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;intersectionObserve&lt;/title&gt; &lt;style type=\"text/css\"&gt; #target &#123; position: relative; top: calc(100vh + 500px); width: 100px; height: 100px; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"target\"&gt;&lt;/div&gt; &lt;div id=\"img\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; let ele = new IntersectionObserver( (entries) =&gt; &#123; console.log(entries); &#125;, &#123; threshold: [0, 0.5, 1.0] &#125; ); ele.observe(img); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我们会看到，虽然我们设定了0.5这个阈值，但实际回调只会在0与1.0时触发。这是一种特殊的处理方式。 上面我们讨论了整个API的核心功能，实际其内部遵循的逻辑如下: 每个观察者实例为所有的目标元素都维护着上次的相交率(previousThreshold)，在新执行Observe的时候会将previousThreshold置为0，之后每次检测到满足threshold的相交率，并且与previousThreshold不同，那么就会触发回调并将previousThreshold重置为这个新值。那么这里可能会有下面几个问题：其一：既然初始值是0，如果阈值设置为0，且刚刚满足滚动到0的位置，回调还会触发吗？实际是会的，这是一种特例，与目标元素在根元素内部(此时相交率为1)滚动到刚刚要超出的位置依然会触发回调函数一样。但是这种情况可能导致一个问题，我们无法直接用intersectionRatio&gt;0来判断目标是否滚入了根元素，因为在慢速滚动下，当目标元素的上边与根元素的下边相交时，此时intersectionRatio=0并且触发了回调，之后当intersectionRatio&gt;0时并不会触发回调了(这里排除还有其他自定义阈值的情况)。这种情况下，可以自定义一个变量值来存展示状态，或者也可以定义一个无限接近0的threshold.其二：如果一个元素初始化就在根元素内部了，然后再执行observe，依然会触发回调吗？会的，因为初始值默认为0，在下一次检测时更新为了实际的相交值。 这里需要强调一点的是，我们的目标元素在Observe的时候可以不存在的[注意这里的不存在是指没有插入dom结构，但是元素本身是需要存在的]，只需要在相交发生时存在就行了，我们来举个栗子： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;intersectionObserve&lt;/title&gt; &lt;style type=\"text/css\"&gt; #target &#123; position: relative; top: calc(100vh + 500px); width: 100px; height: 100px; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"target\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; let ele = new IntersectionObserver( (entries) =&gt; &#123; console.log(entries); &#125;, &#123; threshold: [0, 0.5, 1.0] &#125; ); let img = document.createElement('div'); ele.observe(img); setTimeout(() =&gt; &#123; document.body.appendChild(img); &#125;, 5000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 同理，如果目标元素与根元素处于相交状态，但是在一段时间后目标元素不存在了(比如remove，或者display:none)了，那么此时依然会触发一次回调。但是如果本身就不处于相交状态，然后消失掉了，因为0-&gt;0没有变化，所以不会触发回调，具体如下面的栗子所示： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;intersectionObserve&lt;/title&gt; &lt;style type=\"text/css\"&gt; #target &#123; position: relative; top: calc(100vh + 500px); width: 100px; height: 100px; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"target\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; let ele = new IntersectionObserver( (entries) =&gt; &#123; console.log(entries); &#125; ); ele.observe(target); setTimeout(() =&gt; &#123; document.body.removeChild(target); &#125;, 5000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; IntersectionObserver API与iframe互联网上的很多小广告都是通过iframe嵌入的，而上面我们也说了现有的情况下很难获取iframe在顶层视窗内的曝光，但是使用IntersectionObserver API我们却可以做到这点。下面举个栗子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;intersectionObserve&lt;/title&gt; &lt;style type=\"text/css\"&gt; #root &#123; position: relative; top: calc(100vh + 800px); width: 100px; height: 100px; &#125; #iframe &#123; width: 600px; height: 600px; margin-bottom: 300px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt; &lt;iframe id=\"iframe\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;script&gt; let iframeTemplate = ` &lt;div id=\"target\"&gt;&lt;p&gt;i am iframe&lt;/p&gt;&lt;/div&gt; &lt;style&gt; #target &#123; width: 500px; height: 500px; background: red; &#125; #target p &#123; font-size: 90px; &#125; &lt;/style&gt; &lt;script&gt; let observer = new IntersectionObserver((entries) =&gt; &#123; console.log(entries) &#125;, &#123; threshold: [0,0.5,1.0] &#125;) observer.observe(target) &lt;\\/script&gt;` iframe.src = URL.createObjectURL(new Blob([iframeTemplate], &#123;\"type\": \"text/html\"&#125;)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 从上面的栗子可以看出，使用此API不仅能够使iframe在视窗内出现时触发回调，而且threshold值同样能够起作用。这样一来，大大简化了此类情况下获取曝光的难度。 延迟加载与无限滚动上面我们关于配置参数已经提到了root和threshold，实际上还有一个值：rootMargin。这个值实际就是给根元素添加了一个假想的margin值。其使用场景最普遍的是用于延迟加载。因为如果真的等目标元素与根元素相交的时候再进行加载图片等功能就已经晚了，所以有一个rootMargin值，这样等于根元素延伸开去了，目标元素只要与延伸部分相交就会触发回调，下面我们来继续举个栗子: 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;intersectionObserve&lt;/title&gt; &lt;style type=\"text/css\"&gt; #root &#123; width: 500px; height: 800px; overflow: scroll; background-color: pink; &#125; #target &#123; position: relative; top: calc(100vh + 500px); width: 100px; height: 100px; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt; &lt;div id=\"target\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; let ele = new IntersectionObserver( (entries) =&gt; &#123; console.log(entries); &#125;, &#123; rootMargin: '100px', root: root &#125; ); ele.observe(target); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 很明显，在上面的栗子中，目标元素并没有出现在根元素的视窗里的时候就已经触发回调了。 整个API可以用来实现无限滚动和延迟加载，下面就分别举出两个简单的栗子来启发思路，更完善健壮的功能就交给看官自己去尝试了哦：延迟加载的栗子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;intersectionObserve&lt;/title&gt; &lt;style type=\"text/css\"&gt; .img &#123; height: 1000px; overflow-y: hidden; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li class=\"img\"&gt; &lt;img src=\"\" class=\"img-item\" data-src=\"http://okzzg7ifm.bkt.clouddn.com/cat.png\"/&gt; &lt;/li&gt; &lt;li class=\"img\"&gt; &lt;img src=\"\" class=\"img-item\" data-src=\"http://okzzg7ifm.bkt.clouddn.com/01.png\"/&gt; &lt;/li&gt; &lt;li class=\"img\"&gt; &lt;img src=\"\" class=\"img-item\" data-src=\"http://okzzg7ifm.bkt.clouddn.com/virtualdom.png\"/&gt; &lt;/li&gt; &lt;li class=\"img\"&gt; &lt;img src=\"\" class=\"img-item\" data-src=\"http://okzzg7ifm.bkt.clouddn.com/reactlife.png\"/&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script type=\"text/javascript\"&gt; let ele = new IntersectionObserver( (entries) =&gt; &#123; entries.forEach((entry) =&gt; &#123; if (entry.intersectionRatio &gt; 0) &#123; entry.target.src = entry.target.dataset.src; &#125; &#125;) &#125;, &#123; rootMargin: '100px', threshold: [0.000001] &#125; ); let eleArray = Array.from(document.getElementsByClassName('img-item')); eleArray.forEach((item) =&gt; &#123; ele.observe(item); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 无限滚动的栗子: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;intersectionObserve&lt;/title&gt; &lt;style type=\"text/css\"&gt; .img &#123; height: 1200px; overflow: hidden; &#125; #flag &#123; height: 20px; background-color: pink; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"imgContainer\"&gt; &lt;li class=\"img\"&gt; &lt;img src=\"http://okzzg7ifm.bkt.clouddn.com/cat.png\"/&gt; &lt;/li&gt; &lt;li class=\"img\"&gt; &lt;img src=\"http://okzzg7ifm.bkt.clouddn.com/01.png\"/&gt; &lt;/li&gt; &lt;li class=\"img\"&gt; &lt;img src=\"http://okzzg7ifm.bkt.clouddn.com/virtualdom.png\"/&gt; &lt;/li&gt; &lt;li class=\"img\"&gt; &lt;img src=\"http://okzzg7ifm.bkt.clouddn.com/reactlife.png\"/&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div id=\"flag\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; let imgList = [ 'http://okzzg7ifm.bkt.clouddn.com/immutable-coperation.png', 'http://okzzg7ifm.bkt.clouddn.com/flexdirection.png', 'http://okzzg7ifm.bkt.clouddn.com/immutable-exampleLayout.png' ] let ele = new IntersectionObserver( (entries) =&gt; &#123; if (entries[0].intersectionRatio &gt; 0) &#123; if (imgList.length) &#123; let newImgli = document.createElement('li'); newImgli.setAttribute(\"class\", \"img\"); let newImg = document.createElement('img'); newImg.setAttribute(\"src\", imgList[0]); newImgli.appendChild(newImg); document.getElementById('imgContainer').appendChild(newImgli); imgList.shift(); &#125; &#125; &#125;, &#123; rootMargin: '100px', threshold: [0.000001] &#125; ); ele.observe(flag); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 通篇看下来大家是不是感觉这个API还是很好玩的，然而因为其兼容性，所以使用区域还是受限的。基于此，规范制订者在github上发布了其Polyfill，不过因为是Polyfill，所以在实现性能上肯定是比不上原生的。而且就其github来看，待解决的issue数量还是比较多的。 具体集成到项目中【项目本身基于vue】实际项目里面可能需要使用到曝光的地方相当的多，这里我们就首页进行了尝试，主要有以下几个问题需要解决： 实例的创建时间 observe()调用的时机 dom元素与埋点数据的关联 针对实例的创建时间，因为首页上需要划分区域进行曝光报告，因此我选择在整个页面的初始化的时候就进行实例的创建。同时，因为希望整个埋点的处理逻辑一致，在实例的回调里面进行了统一处理。具体如下： 1234567891011...... this.ele = new IntersectionObserver((entries) =&gt; &#123; entries.forEach((item) =&gt; &#123; if (item.intersectionRatio &gt; 0) &#123; let node = item.target.querySelector('.need-data'); console.log(node.attributes['code'].value); &#125; &#125;) &#125;, &#123; threshold: [0.000001] &#125;); observe()调用的时机，因为页面采用组件化的方式，在最初进行实例化的时候，需要的dom结构都是没有的。之后通过与后端进行数据，采用数据驱动进行页面渲染。因此在数据获取后在下一次DOM循环更新之后才进行observe()的调用。此时所需的dom结构都有了。 123456this.$nextTick(() =&gt; &#123; let newArray = Array.from(document.getElementsByClassName('need-data')); newArray.forEach((newItem) =&gt; &#123; this.ele.observe(newItem); &#125;) &#125;) dom元素与埋点数据的关联，因为之前的逻辑中我们的dom与业务数据耦合度不大，因此获取单纯的dom后无法获取需要上报的数据。同时我们希望这一块对于大部分的曝光需求能够进行逻辑统一。因此我们采取了最简单的方法，将需要上报的数据直接放在dom的一个属性中。因为这部分dom是组件化生成的一部分，所以逻辑上也是一致的。 123&lt;div class=\"item-content clearfix\" :class=\"'item-wrapper-type'+type\" :code=\"needData.code\"&gt;....&lt;/div&gt; 基本进行这三个地方的改动后就能满足我们的大部分类型的需求了。其最后的结果如下: 利弊介绍 优 性能比直接的监听scroll事件或者设置timer都好 使用简单 利用它的功能组合可以实现很多其他效果，比如无限滚动等 对iframe的支持好 缺 兼容性不好 它不是完美像素与无延迟的，毕竟根本上是异步的。因此不适合做滚动动画 参考 IntersectionObserver API: 强烈推荐这篇文章，干货满满 Intersection Observer Intersection Observer API Timing element visibility with the Intersection Observer API","tags":[{"name":"data","slug":"data","permalink":"http://memory.lulutia.com/tags/data/"}]},{"title":"基于React-Native及Redux的Immutable.js引入","date":"2017-07-10T09:06:08.000Z","path":"2017/07/10/immutableJS/","text":"本文主要介绍了如何对RN项目进行render count的优化，着重介绍了Immutable.js及其如何与Redux和React Native融合。 前菜之背景介绍话说某天，楼主吃着火锅唱着歌，逛到了React的Performance Tools版块，心血来潮，放到了手上的项目里面玩了玩，看完后整个人都不太好了，数据如下(我一页屏幕都截不完……)：但实际上我所执行的操作仅仅只是为颜色外观打了个分，如下所示： 根据上面的统计数据，初略计算了下，一个打分操作render count为293。一个页面必填5个打分项，如此一来总共render count &gt;= 1465，其中还排除了用户打分完毕后继续修改的情况。不用我说，大家也能看出这是一个相当不合理的数字。因为就理想状况而言，打分操作最多只影响当前的打分项，一个打分组件五颗星，其具体结构如下所示: 12345678&lt;View key=&#123;i&#125;&gt; &lt;TouchableOpacity style=&#123;&#123;marginTop: 5, marginRight: 5&#125;&#125; onPress=&#123;() =&gt;&#123;......&#125; &gt; &lt;IconFont name=\"star\" size=&#123;StyleSheet.r(22)&#125; color=&#123;color&#125;/&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; 因此直接改变量为3*5=15是比较合理，再加上全局的Navar以及connect等操作，render count达到293也是绝对不合理且，通过分析，我们可以看到有很多数据根本没改变的组件也被重新渲染了的，这部分开销完全是不必要且有相当大的改进空间的。既然如此，我们来改进下吧~ 为了减少环境变量且便于修改与测试，我们基于种子项目来模拟当前的状况。种子项目在React Native官方项目基础上集成了Redux进行数据处理，除此之外还提供了一些基本的工具函数及路由封装。我们构造了两个页面，点击第一个页面的button会跳转到第二个页面，在第二个页面会从服务器端获取数据，渲染成列表形式，除此之外在列表上方有一个button，它会记录点击次数并且展示出来。大概布局如下： 既然是模拟前文的情况，那我们可以预测点击addCount button后，整个列表应该是被重新渲染了的，虽然他的数据实际上并没有变化，讲道理是不应该重新渲染的。实际结果如下图所示，的确和我们的预测一样，List下的Text render count是不必要的。 这里有一个点要注意，所谓的重新渲染指的是在virtual dom层面的。下图是整个渲染过程开始到结束的主要流程，而本文关心的是下图黄色框中的部分，而重中之重是黄色框中的第三部: 其后代组件执行Update。 因为我们采用Redux进行数据处理，每个页面的initailState为一个对象，而从不直接修改state 是Redux 的核心理念之一，所以触发action后reducer返回的是一个新的对象。这一流程相当于执行了setState操作，因此整个页面开始执行dirty的标记，因为是新对象，所以几乎所有与state相关的组件及其后代组件都要执行Update的流程，如果我们不对Update的流程进行特殊定制，则shouldComponentUpdate默认返回true，之后执行render函数。因此，出现了上述中多次不必要render的情况。所以，首要任务是添加shouldComponentUpdate函数进行处理。但是这里会有两个明显的问题： 每个页面，甚至每个组件的state，props结构不一样，很难有统一的对比函数 state，props的结构可能很复杂，一步步的循环迭代对比对性能的消耗可能很大 针对shouldComponentUpdate，React提供了PureRenderMixin的方式来进行处理，但是这种方式其进行的只是浅对比，如果是复杂数据结构的深层次不一样，它也可能返回false。因此只能处理简单的数据结构，或者针对开发者对整个state层次有完全的把握，能够在深层次变化后显示调用this.forceUpdate()的情况。显然与我们的需求不符。此时，本文的主题Immutable.js终于要出场了。 主菜之Immutable.js介绍讨论Immutable.js之前，我们首先看看啥叫Immutable。来，看看维基百科的定义： In object-oriented and functional programming, an immutable object is an object whose state cannot be modified after it is created.This is in contrast to a mutable object (changeable object), which can be modified after it is created. 需要解决的问题 减少复杂性，增加代码的可控性 对于immutable object在创建后就再也不能修改了，而mutable object却可以修改，举个很简单的栗子： 123let fruit = &#123;apple: 1&#125;;friuit.apple = 2;fruit; // &#123;apple: 2&#125; 上面这种特性在频繁需要修改原对象的时候特别好用，可以节约内存。但是这种灵活性往往以可控性为代价，多处使用中的任意一处修改都会影响所有的使用，比如下面的栗子： 123let animal = &#123;dog: 1&#125;;changeAnimalCount(animal);animal; // ? 经过函数调用后，我们谁都不知道animal变成了啥样 = =。处理这种情况，我们往往需要执行深拷贝，然后在拷贝出的对象上执行操作，这样可以保证数据的可控性，但这个又往往以内存的大量使用为代价。特别不巧的是，我们的项目中还真的有很多地方用到了深拷贝，并且为了这个操作引入了extend库。因此，如何在花费很少的情况下对state的状态做一个很好的记录成为了一个问题。 减少UI框架中View层与Model层的耦合 在我们进行应用交互时，我们相当关注状态的改变，因为状态的改变意味着我们需要做哪些UI层面的变动，这部分是数据驱动的。简单的说，我们可能实现下面的代码： 12345let storeData = &#123;key: 'before'&#125;;renderUI(storeData);getDataFromServer(url, ()=&gt;&#123; renderUI(storeData);&#125;) 但是上面这种情况造成的问题是，也许和服务器交互后的数据根本没有改变，然而我们要执行UI渲染。或者的确执行了UI渲染，但是我们并不知道是具体的哪块数据进行了变动。因此我们可能改良出下面的代码： 123456let storeData = &#123;key: 'before'&#125;;renderUI(storeData);Object.observer(storeData, (changes) =&gt; &#123; renderUI(storeData, changes);&#125;)getDataFromServer(url); 这种情况下，我们通过Object.observer()来对数据进行监听，这样至少我们知道哪些数据进行了变化。但是这种情况下依然有问题，因为Object.observer()执行的只是第一层的比较，因此如果是深层次的变化它依然没法处理。同时，如果数据变化频繁的情况下，它也做了很多的无用功，毕竟我们只关心最后的状态。因此现在的做法基本是使用如下所示的： 12345678910111213141516let data = &#123; dirty: false, _raw: &#123;key: 'value'&#125;, get: function (key) &#123; ... &#125;, set: function (key, newValue) &#123; ... this.dirty = true; &#125;&#125;function renderUI(data) &#123; if (!data.dirty) &#123;return;&#125; data.dirty = false; ...&#125; 但是这种情况如果同时对一个状态进行多种渲染，因为在第一个渲染中已经改变了dirty的状态，这样并不会调用第二个渲染，如下： 123...renderTop(data);renderBottom(data); 因此，既然每一个render都要执行dirty状态的检测，所以可以建立一个UI框架，将这层检测包裹进去，而不用使用者自己来做。但这样一来Model层和View层就耦合了。因此，如何在不对MV进行强耦合的情况下对数据的变化进行监听成为了一个问题。 处理缓存 当我们在处理一些消耗很大的操作时，我们可能希望将之前的结果存储起来而不是每一次都重新计算。比如像下面这样： 123456function expensiveCoperation() &#123; ...&#125;let data = memorize(expensiveCoperation);let initialData = ...;data(initialData); 市面上有很多对于memorize的实现，比如下面这个： 1234567function memorize(fn) &#123; let cache = &#123;&#125;; return function(arg) &#123; let hash = arg === Object(arg) ? JSON.stringify(arg) : currentArg; return hash in cache ? cache[hash] : (cache[hash] = fn.call(this, arg)); &#125;&#125; 但是上面这种实现里面的JSON.stringify()是一个O(n)的操作，当数据量够大时，执行这个函数的操作说不定还没有不执行的快。在具体实现中也许我们可以简化这个操作，只对比前一次的输入和这一次的输入，只关心前一次的结果和这一次的结果。此时我们便可以不必使用JSON.stringify了。实际上React中的shouldComponentUpdate就是只对前一次状态和这一次状态进行对比。但对比时我们其实进行的是值的对比而不是引用的对比。所以缓存性能的提高最后落脚点到如何快速进行值的比较。因此，如何对复杂结构的值进行对比成为了一个问题。 解决办法 针对以上问题，Immutable.js提出了一下几个解决方案： 持久化结构数据 所谓持久化结构数据即Persistent data structire，我们来看维基百科的定义： In computing, a persistent data structure is a data structure that always preserves the previous version of itself when it is modified. Such data structures are effectively immutable, as their operations do not (visibly) update the structure in-place, but instead always yield a new updated structure. 我们如果用时间流的概念来看这个问题，即每一次改变都保存了一个类似快照的东西，之后的改变并不会影响之前的快照。这样我们就能够对state的变化做一个很好的记录，解决了上面的第一个问题。但是你可能会担心这样等于说是进行拷贝，会耗费很多内存，因此请看下面的解决方案。 结构共享 当我们使用一个新的值时，我们希望能够尽量复用老值不变的部分，因为这样意味着少量的copy操作和少量的内存使用。数据结构中的有向无环图可以实现这个需求。但是JS中基本的数据结构Array和Object显然都不是用DAG[Directed Acyclic Graph]实现的。因此Immutable.js等于用Trie自己实现了一套数据结构。基本的思路如下： 每个节点都有自己的hashCode，因此比较两个对象时，实际就是比较其hashCode，这样就避免了深度遍历。 惰性加载 在Immutable.js中提供了Seq来执行惰性加载。Seq执行最小的工作来对任何方法作出反应。比如： 1234const oddSquares = Seq([ 1, 2, 3, 4, 5, 6, 7, 8 ]) .filter(x =&gt; x % 2) .map(x =&gt; x * x) console.log(oddSquares.get(1)); //9 上面这个例子filter将只会执行三次，而map只会执行一次。这种特性对于处理大型数据相当有用。 其他 Immutable的特性意味着它特别适合用于多线程开发，它避免了很多不必要的锁的存在。虽然这点对于现在的JS没啥作用，但谁知道未来呢，毕竟多核已经越来越普遍。 基本API Immutable.js主要提供了下面几种数据类型： List：类似Array Map：类似Object OrderedMap：在Map的基础上根据set顺序进行排序 Set： 类似ES6中的Set OrderedSet：在Set的基础上根据add顺序进行排序 Stack：有序集合，进行unshift和shift的操作复杂度为O(1) Range(start, end, step)：返回Seq.Indexed类型数据的集合 Repeat(value, times)：返回Seq.Indexed类型的数据集合，重复times生成value值 Record：；类似ES6中的Class，细节上不同 Seq：序列 Iterable：可以被迭代的key，value集合，是其他所有集合的基类 Collection：抽象类，无法直接构建此类型 其中最常用的是List和Map。 常用API： fromJS(): 最常用的将原生JS数据转换为Immutable数据的转换方法 1const data = Immutable.from(&#123;a: &#123;b: [10, 11]&#125;&#125;); toJS(): 将Immutable数据转换为原生JS set() 123456const originalList = List([ 0 ]);// List [ 0 ]originalList.set(1, 1);// List [ 0, 1 ] List().set(50000, 'value').size;// 50001 setIn(): 进行深度赋值 123const list = List([ 0, 1, 2, List([ 3, 4 ])])list.setIn([3, 0], 999);// List [ 0, 1, 2, List [ 999, 4 ] ] get() 12const list = List([ 0 ]);let value = list.get(0); // 0 getIn(): 进行深度取值 12const list = List([ 0, 1, 2, List([ 3, 4 ])]);let value = list.getIn([3, 0]); // 3 is(): 进行值对比[对于复杂对象其实是hashCode的对比] 12345const map1 = Map(&#123; a: 1, b: 1, c: 1 &#125;)const map2 = Map(&#123; a: 1, b: 1, c: 1 &#125;)assert(map1 !== map2)assert(Object.is(map1, map2) === false)assert(is(map1, map2) === true) 除了上面这些，Immutable.js基本提供了所有的对应原生操作的方法，具体见这里 甜点之具体集成到RN+Redux的项目中在第一点中我们分析了遇到的优化点，在第二点中我们讲解了能进行优化的工具，现在我们来进行具体的优化。 combineReducers的切换 我们之前combineReducers用的是Redux提供的，但是它只能处理原生JS，所以我们需要引入redux-immutable，它提供的combineReducers可以处理Immutable数据 1234567891011import &#123;createStore, applyMiddleware, compose&#125; from 'redux';import &#123;combineReducers&#125; from 'redux-immutable';...export default (data = Immutable.Map(&#123;&#125;)) =&gt; &#123; const rootReducer = combineReducers(&#123; route: routeReducer, modules: combineReducers(reducers) &#125;); return createStore(rootReducer, data, middleware);&#125;; 每个Reducer的初始化数据也应该采用Immutable数据 1234const initialState = Immutable.Map(&#123; dataList: Immutable.List([]), count1: 0&#125;); 与服务端数据的交互在第获取一时间转换为Immutable数据，在发送第一时间转化为原生数据 12345678910111213141516return fetch(url).then((res) =&gt; &#123; return res.json(); &#125;, (er) =&gt; &#123;console.log(er);&#125;).then((data) =&gt; &#123; data = Immutable.fromJS(data || &#123;&#125;); dispatch(&#123; type: GETDATA_END, payload: &#123; dataList: data.get('data') &#125; &#125;); &#125;, (error) =&gt; &#123; console.log(error); dispatch(&#123; type: GETDATA_BEGIN &#125;); &#125;); 这里需要注意以下两点： 如果使用安卓模拟器，且使用localhost的数据，需要直接填写localhost的ip地址。因为模拟器有自己的localhost ip，如果直接用localhost就指向了它提供的地址，而不是本机的地址了 如果使用iOS模拟器，其请求的是http协议的地址，需要在info.plist开启对http的支持，如下： 12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; 因为Persistent data structire，Reducer返回的数据不用新建一个对象了 1234[GETDATA_END]: (state, action) =&gt; &#123; const &#123;dataList&#125; = action.payload; return state.set('dataList', dataList); &#125;, shouldComponentUpdate可以进行统一处理了 123456789101112131415161718192021222324shouldComponentUpdate(nextProps, nextState) &#123; const thisProps = this.props || &#123;&#125;; const thisState = this.state || &#123;&#125;; nextState = nextState || &#123;&#125;; nextProps = nextProps || &#123;&#125;; if (Object.keys(thisProps).length !== Object.keys(nextProps).length || Object.keys(thisState).length !== Object.keys(nextState).length) &#123; return true; &#125; for (const key in nextProps) &#123; if (!Immutable.is(thisProps[key], nextProps[key])) &#123; return true; &#125; &#125; for (const key in nextState) &#123; if (!Immutable.is(thisState[key], nextState[key])) &#123; return true; &#125; &#125; return false;&#125; 函数的传递方式需要注意 如果每次render时都是重新声明的函数，则其对比会有问题，因为is()内部对函数的对比是基于ValueOf的，所以将下面的第一种方式改为第二种方式： 123&lt;TouchableOpacity onPress=&#123;() =&gt; this.addCount()&#125; style=&#123;Style.btnContainer&#125;&gt; &lt;Text style=&#123;Style.btnWord&#125;&gt;addCount&lt;/Text&gt; &lt;/TouchableOpacity&gt; 123&lt;TouchableOpacity onPress=&#123;this.addCount&#125; style=&#123;Style.btnContainer&#125;&gt; &lt;Text style=&#123;Style.btnWord&#125;&gt;addCount&lt;/Text&gt; &lt;/TouchableOpacity&gt; 经过上面这些改造后，我们的demo文件Render count如下所示，很好，楼主又可以欢快的吃火锅啦： 酒水之利弊介绍 优 能便利的进行时间溯洄，便于状态的把控与调试 结构共享，节约内存 并发安全 能抽象出统一的对比函数 Model与View耦合度不高 缺 有学习成本 容易与原生函数混淆，并且原生函数一旦重写可能会导致问题 资源大小增加 跨页面数据同步方式会有变动，之前页面间进行引用传递，在B页面进行的修改会自动呈现到A页面，但是现在是Persistent data structire，因此B页面的改动A页面无感，需要特殊的触发机制来进行状态同步 因为并非原生的数据结构，所以像解构这种用法需要引入特殊的库后才能使用 参考 React.js Conf 2015 - Immutable Data and React Optimizing Performance Immutable.js Immutable.js 以及在 react+redux 项目中的实践 Immutable 详解及 React 中实践 从 React 的组件更新谈 Immutable 的应用","tags":[{"name":"React Native","slug":"React-Native","permalink":"http://memory.lulutia.com/tags/React-Native/"},{"name":"React","slug":"React","permalink":"http://memory.lulutia.com/tags/React/"},{"name":"optimization","slug":"optimization","permalink":"http://memory.lulutia.com/tags/optimization/"}]},{"title":"React Native 学习系列二","date":"2017-07-06T08:58:30.000Z","path":"2017/07/06/reactnative02/","text":"状态管理 历史情况 最早的服务器端渲染: 新的请求发送到服务器端，服务器端返回一个新的页面，然后浏览器进行渲染。导致基本上任何与UI相关的数据变化时，都要全部重新走完整个绘制流程 人工重绘界面: 交互产生事件，事件对应预先设定的重绘逻辑。导致代码中充斥着人工的处理渲染的逻辑 数据绑定: 在UI上增加了监听器，当监听器接收到事件变更时自动知道如何处理。这种方式需要在一开始就设置所有的绑定，当事件发生时，只有那些确实需要变化的进行变化。这种方式对事件变更本身会进行一层处理，导致需要按照特定的API进行处理 脏检测: 创建了值的观察器，一旦应用中发生变化，就检测这个观察器里的值是否与之前的值相同，如果不同就重新渲染这个值到UI。这种方式因为没有告诉框架是否变了以及什么地方变化了，所以只能通过外部来检查，比如有一种方法就是一旦交互产生，就重新把所有观察器跑一遍。这种方式遇见UI比较复杂或者重绘经常性发生时就很可能产生性能问题 虚拟DOM: 思想上与服务器端渲染类似。只要状态发生变化，就全部重新渲染一次。但是其不同的地方在于他不是在真正DOM上执行这个操作，而是渲染到虚拟DOM，即一个轻量的纯javaScript的对象结构，里面是简单对象和数组来表达真实的DOM对象。之后再通过一个特殊的过程根据这个虚拟DOM来创建真实DOM。因此当一个值发生变化时，会通过对比新生成的虚拟DOM与之前的虚拟DOM而找出涉及DOM的变化，之后将变化反应在真正的DOM上。这种方式不用跟踪变动，减少了昂贵的DOM操作，这部分的详细了解推荐通过virtual-dom这个项目来进行分析，总的来说流程如下: JSX 什么是JSX It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.JSX produces React “elements”. 我们可以看见两个关键点： 它是JS的语法扩展(我们可以理解我为它就是一个比较高级的语法糖) 与模板语言不一样，它能利用JS自带的语法和特性。因此基本会写JS就能写JSX，学习成本低，并且能利用JS本身的语法 React基于Virtual DOM创造的JSX，JSX创造的是React element，它不是真正的DOM，因此也意味着在没有真正DOM的情况下，它也能模拟DOM的行为(React-Native中实际也没有真正的DOM) 具体行为 以react举例下面两段代码完全一致： 12var p1 = React.createElement('p', null, 'my test')var root = React.createElement('div', &#123; className: 'root-div' &#125;, p1); 12345var root = ( &lt;div className='root-div'&gt; &lt;p&gt;my test&lt;/p&gt; &lt;/div&gt;) JSX之后会被专门的解释器解释为JS(在打包阶段就完成了，因此不会有性能上的问题)再执行 JSX语法 在JSX中你可以使用{}来包裹JS表达式，下面以RN来举例 1234&#123;refundDetailData.return.returnPics &amp;&amp; &lt;View style=&#123;[Style.basicLayout, Style.image]&#125;&gt; &lt;Text style=&#123;[Style.textColor, Style.navTitle]&#125;&gt;图片信息:&lt;/Text&gt; &lt;ImageShow picUrls=&#123;refundDetailData.return.returnPics&#125;/&gt; &lt;/View&gt;&#125; JSX本身也是一种表达式，因此可以在if语句，for循环等各种场合中使用 12345678dataList.map((item, index) =&gt; ( &lt;TouchableHighlight key=&#123;index&#125;&gt; &lt;View&gt; &lt;Text&gt;&#123;item.contactName&#125;&lt;/Text&gt; &lt;Text&gt;&#123;item.contactTel&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt;)); JSX可以定义属性，一般每个组件都会接受一组属性(props) 属性的名字可以自定义 属性的值能够是变量，当属性值是变量时需要通过{}包裹起来，此时注意如果在这个大括号外层用双引号包裹，则此时整条语句会作为字符串进行解析，而不是变量了 虽然JSX与HTML有很多类似处，但是其最后还是编译为JS的，因此，在React DOM中的属性名是遵循驼峰命名法的 当忽略属性的值时，JSX会按照true来对待它。而不使用属性时，其对应的值与组件实现内部默认值有关 1234567&#123;/*下面两条代码实现的效果一样*/&#125;&lt;Input type=\"button\" disabled /&gt;;&lt;Input type=\"button\" disabled=&#123;true&#125; /&gt;;&#123;/*下面两条代码实现的效果一样*/&#125;&lt;Input type=\"button\" /&gt;;&lt;Input type=\"button\" disabled=&#123;false&#125; /&gt;; JSX标签能够包含子元素就如HTML一样，而且其子元素也可以运用JS的语法进行构建 JSX中的注释就如JS类似，但是需要注意当在子元素中进行注释时，需要用{}将注释包裹起来 123456789&lt;Nav&gt; &#123;/* child comment, put &#123;&#125; around */&#125; &lt;Person /* multi line comment */ name=&#123;window.isLoggedIn ? window.name : ''&#125; // end of line comment /&gt; &lt;/Nav&gt; JSX中的事件处理是直接绑定在组件上的，下面以RN为例 123&lt;TouchableHighlight style=&#123;Style.tabBtn&#125; underlayColor=&#123;Colors.yellowLighten&#125;onPress=&#123;this.goToReturnList&#125;&gt; &lt;Text style=&#123;Style.tabBtnText&#125;&gt;退货单&lt;/Text&gt;&lt;/TouchableHighlight&gt; 相比于使用下面这种方式，界面元素和业务逻辑的耦合会更加明显 1$('#my-button').on('click', this.checkAndSubmit.bind(this)); 在JSX中，需要注意事件名依然按照驼峰命名法来进行，而大括号中就是事件触发时返回的事件处理函数。JSX中绑定的事件自动进行了解绑处理，当对应的DOM不存在时，其绑定的事件就自动解绑了。 React有一个模拟事件系统。它并不会将事件绑定到真正的节点上，当React启动时，他开始在顶层用一个单独的事件监听器来监听所有的事件。当一个组件加载或者移除时，它绑定的事件将在一个内置的映射上被添加或者移除。当事件真正触发时，React知道如何运用这个映射来dispatch这个事件。 虽然整个事件系统由React来管理了，但是其API和使用方法与原生事件一致。因此做到了浏览器的兼容。 生命周期 在React中，组件只是一种状态机，整个UI的渲染可以算做是状态驱动的。你更新一个组件的状态，然后根据新的状态渲染UI，React会以一种最效率的方式来更新DOM 大多数组件只需要根据传入的props里面的数据进行渲染，属性是在组件初始化之后就从父级组件带入到组件内部。我们无法在使用的过程中对组件的属性进行修改。但是当需要对用户输入，时间的流逝，服务端请求作出反应时，需要用state来进行状态记录，state是实际上组件中使用的数据，它可以被修改 在React中，通过调用setState(data, callback)来告诉它数据变动了，这个方法将data合并进this.state，之后告诉组件状态变动了需要进行重新渲染，callback会在重新渲染完毕后被调用。注意setState()这个方法是异步的，同步的多个setState方法只会触发一次实际render 组件在实例化之后就开始了它的生命周期过程。它的整个生命周期主要由以下几个部分组成: getDefaultProps():在组件类创建的时候调用一次，然后返回值被缓存下来, 它返回的任何复杂对象用于设置默认的props, 并且这些将会在实例间共享，而不是每个实例拥有一份拷贝。注意只能在子组件或组件树上调用setProps。别调用this.setProps或者直接修改this.props。可以通propTypes对props的类型进行验证 1234static propTypes = &#123; data: PropTypes.object, pickerNameStyle: Text.propTypes.style &#125;; getInitialState():在组件挂载之前调用一次。返回值将会作为 this.state的初始值。这个方法执行时已经可以访问组件的props。注意state是每个组件自带的，而props是所有实例共享的 componentWillMount():在初始化渲染执行之前立刻调用，且只调用一次，这是渲染前最后修改state的机会 render():render方法返回的结果并不是真正的DOM元素，而是一个虚拟的表现，类似于一个DOM tree的结构的对象。它是唯一一个必须的方法。在这个方法中，会检测this.props和this.state，返回一个单子级组件,当然也可以返回null或者false。render函数不应该修改state,操作DOM或者与浏览器交互 componentDidMount():在初始化渲染执行之后立刻调用一次,在生命周期中的这个时间点，组件拥有一个DOM展现[即虚拟DOM构建完毕]，你可以通过this.getDOMNode()来获取相应DOM节点。当需要从组件获取真实DOM的节点，可以使用ref属性。注意在RN中，是先调用子组件的componentDidMount()，然后调用父组件的函数。这个函数之后，就进入了稳定运行状态，等待事件触发 1234567......return &lt;canvas ref='mainCanvas'&gt;......componentDidMount: function()&#123; var canvas = this.refs.mainCanvas.getDOMNode(); //可以访问到 Canvas 节点&#125; componentWillReceiveProps():用此函数可以作为react在props传入之后，render()渲染之前更新state的机会,新的props是传入的,老的props可以通过this.props来获取。注意在该函数中调用this.setState()将不会引起二次渲染 12345componentWillReceiveProps: function(nextProps) &#123; this.setState(&#123; likesIncreasing: nextProps.likeCount &gt; this.props.likeCount &#125;);&#125; shouldComponentUpdate():在接收到新的props或者state,将要渲染之前调用。如果shouldComponentUpdate返回false,则render()将不会执行,直到下一次state改变。(通过此函数可以提高性能) componentWillUpdate():和componentWillMount类似,在组件接收到了新的props或者state即将进行重新渲染前调用,注意你不能在该方法中使用this.setState()。如果需要更新state来响应某个prop的改变,请使用componentWillReceiveProps。紧接着这个函数，就会调用render()来更新界面了 componentDidUpdate():和componentDidMount类似,使用该方法可以在组件更新之后操作DOM元素 componentWillUnmount():当组件从DOM中移除的时候立刻调用来完成所有的清理和销毁工作,在conponentDidMount中添加的任务都需要再该方法中撤销,如创建的定时器或事件监听器 运行组件UI example 运行官方案例(即在虚拟机上查看RN各个组件的实际效果) 运行方法 运行过程中可能出现的问题 What went wrong: Execution failed for task ‘:ReactAndroid:buildReactNdkLib’. 解决办法 安卓新项目起不来 解决办法: 注意下是不是老项目的shell还在运行，需要重新编译链接一次 官方组件举例 ScrollView ScrollView是一个普通的可滚动容器，它能包含多个组件和View。 ScrollView能纵向滚动也能横向滚动 ScrollView一般用来展示限制尺寸的少量东西。因为所有ScrollView里面的元素和组件都会被渲染，不管它当前是否展示在屏幕上。 ScrollView必须有一个确定的高度才能正常工作，因为滚动的本质就是将一系列不确定高度的子组件装进一个确定高度的容器 属性 contentContainerStyle：传入的样式属性，其作为样式会应用在包裹所有子元素的内容元素容器上 horizontal：确定横向还是纵向滚动，默认为false，即默认纵向滚动 123456789&lt;ScrollView style=&#123;styles.listTab&#125; horizontal&gt; &#123;this.level.map((item, index) =&gt; &#123; return ( &lt;View style=&#123;styles.tabTextContainer&#125; key=&#123;index&#125;&gt; &lt;Text&gt;&#123;item&#125;&lt;/Text&gt; &lt;/View&gt; ) &#125;)&#125; &lt;/ScrollView&gt; keyboardDismissMode：决定当拖拽时，键盘是否消失 none：默认，拖拽不会让键盘消失 on-drag：当拖拽开始时，键盘消失 interactive：安卓上不支持，键盘伴随拖拽操作同步地消失，并且如果往上滑动会恢复键盘 keyboardShouldPersistTaps：决定当点击时，键盘是否可见。这个属性特别重要。比如ScrollView里面有很多输入框时，我们希望点击输入框是输入框本身拿到事件，而键盘并不会在切换时进行关闭再打开的操作。 never：默认，当点击文本输入框之外时，如果键盘是打开的则关闭键盘。当这个发生时，子元素将不会接收到点击事件 always：键盘将不会自动关闭，并且scroll view不会捕捉到点击事件，但是子元素能够捕捉到点击事件 handle：键盘将不会自动关闭当点击是由子元素触发的 false：用never替代 true：用always替代 onContentSizeChange：当滚动视图的内容尺寸大小发生变化的时候调用 1234567891011121314151617this.level = ['我常买', '热卖', '一级类目', '鸡腿系列', '海鲜系列', '鸭制品系列'];...&lt;TouchableHighlight onPress=&#123;() =&gt; &#123;this.level.pop(); this.forceUpdate();&#125;&#125;&gt; &lt;View style=&#123;styles.button&#125; &gt; &lt;Text style=&#123;styles.add&#125;&gt;+&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; ... &lt;ScrollView style=&#123;styles.listTab&#125; horizontal onContentSizeChange=&#123;(contentWidth, contentHeight) =&gt; &#123;console.debug(contentWidth, contentHeight);&#125;&#125;&gt; &#123;this.level.map((item, index) =&gt; &#123; return ( &lt;View style=&#123;styles.tabTextContainer&#125; key=&#123;index&#125;&gt; &lt;Text&gt;&#123;item&#125;&lt;/Text&gt; &lt;/View&gt; ) &#125;)&#125; &lt;/ScrollView&gt; onScroll：该方法在滚动的时候每frame(帧)调用一次，调用的频率可以用scrollEventThrottle属性来控制。当滚动到边界后无法触发 refreshControl：一个refreshControl组件，主要在下拉刷新时使用 pagingEnabled：默认false，当为true时，scroll view会停留在其尺寸的倍数的位置。这个能够被用在在横向翻页。具体表现就是，超过Scroll View尺寸一点时页面会自动会回退回去，超过很多但是尚未到达其尺寸两倍的位置，则会向前到达其两倍尺寸的位置，之后如此类推 removeClippedSubviews：默认为true，在ScrollView视图之外的子视图(该视图的overflow属性值必须要为hidden)会被暂时移除，该设置可以提高滚动的性能 scrollEnabled：默认true，当为false时，内容不会滚动 showsHorizontalScrollIndicator：默认true，当为true时，横向滚动会展示滑条 showsVerticalScrollIndicator：默认true，当为true时，纵向滚动会展示滑条 仅Android支持的属性: endFillColor：当滚动内容没填充满Scroll View时设定填充不满的区域 scrollPerfTag：在Scroll View上记录滚动性能的标签 仅iOS支持的属性: alwaysBounceHorizontal：横向弹簧效果，当horizontal ={true}默认是true，horizontal={false}默认是false alwaysBounceVertical：纵向弹簧效果，当horizontal ={true}默认是false，horizontal={false}默认是true automaticallyAdjustContentInsets：默认true，自动调节内容内偏移，控制是否自动调节内容内偏移以便于一个navigation bar或者tab bar或者toolbar不挡住Scrollview中的内容 bounces：默认true，控制水平方向与垂直方向的弹簧效果，优先级比alwaysBounce* 属性高 bouncesZoom：控制拉近与缩小超过限制时是否有弹性动画，当为true时有 canCancelContentTouches：默认true，控制ScrollView是否可以拖动，如果为false不能拖动 centerContent：默认false，为true时如果ScrollView中内容小于ScrollView的边界，则它们自动居中，超过边界时无效 contentInset：内部内容距离ScrollView边界的内偏移量，默认为{top: 0, left: 0, bottom: 0, right: 0} contentOffset：用来手动设置起始滚动偏移量。默认为 {x: 0,y: 0} decelerationRate：指定手指抬起减速速率 normal: 0.998，为默认 fast: 0.99 也可以指定一个浮点数，确定减速快慢 directionalLockEnabled：默认false，为true时控制只有一个方向可以滚动当拖拽 indicatorStyle：指示器样式，default与black相同，black与白色背景搭配，white与黑色背景搭配 maximumZoomScale：默认是1.0，放大的最大系数 minimumZoomScale：默认是1.0，缩小的最大系数 onScrollAnimationEnd：滚动动画完成后触发 scrollEventThrottle：控制滚动时滚动事件触发频率 scrollIndicatorInsets： {top: number, left: number, bottom: number, right: number}，指定指示器内偏移量，应与contentInset值相同，默认{0, 0, 0, 0} scrollsToTop：默认true，默认true时，Scroll View滚动到顶部当状态条被点击时 snapToAlignment：当snapToInterval指定时，这个属性定义这个停驻点相对于Scroll View的关系。 start (默认) 会将停驻点对齐在左侧（水平）或顶部（垂直） center 会将停驻点对齐到中间 end 会将停驻点对齐到右侧（水平）或底部（垂直） snapToInterval：当指定时，会导致Scroll View停留在这个参数的倍数的位置。这个属性一般与snapToAlignment一起用 stickyHeaderIndices：子元素索引构成的数组，用来指定滚动时这些元素停靠到界面的顶部，比如传递stickyHeaderIndices={[0]}将让第一个子元素固定到Scroll View的顶部。当horizontal={true}时，这个属性不支持 zoomScale：当前Scroll View内容的缩放比例 方法 scrollTo()：例如scrollTo({x: 0; y: 0; animated: true})，滚动到指定的x, y偏移处。第三个参数为是否启用平滑滚动动画 scrollToEnd()：如果是纵向的滚动，则滚动到底部，如果是横向，则滚动到右部 官方API举例 BackHandler 监听硬件的back键操作。如果没有任何监听函数，或者监听函数的返回值不是true，则会调用默认的back键功能来退出应用 1234567this.backAndroidListener = BackHandler.addEventListener('hardwareBackPress', () =&gt; &#123; if (navigator.getCurrentRoutes().length &gt; 1) &#123; navigator.pop(); return true; &#125; return this.onExitApp(); &#125;); 方法： exitApp：当你在监听里面无法立刻判断是否要退出，比如你需要获取异步操作执行成功后再调用，此时可以用这个函数来退出 addEventListener：绑定监听函数 removeEventListener：移除监听函数 参考 Change And Its Detection In JavaScript Frameworks React Native 中组件的生命周期 How JavaScript Event Delegation Works 深入浅出React（三）：理解JSX和组件","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://memory.lulutia.com/tags/ReactNative/"}]},{"title":"React Native 学习系列一","date":"2017-07-06T07:11:10.000Z","path":"2017/07/06/reactnative01/","text":"背景介绍 创造者: Facebook 时间: React.js Conf 2015 上发布，9月推出Android版本 使用范围: 用于开发iOS和Android原生应用 设计理念: 既拥有Native的用户体验、又保留React的开发效率 产生原因: Native的原生控件有更好的体验，有更好的手势识别，有更合适的线程模型，能实现更精细的动画 Native开发成本高 发展趋势: 开源不到1周github上star破万 基本特点: Learn once, write anywhere 用React.js抽象操作系统的原生UI组件，继而代替DOM元素来渲染 具备流畅和反应灵敏的优势 在后台，React Native运行在主线程之外，而在另一个专门的后台线程里运行JavaScript引擎，两个线程之间通过异步消息协议来通信。 对应技术栈 JSX vs HTML CSS-layout vs css ECMAScript 6 vs ECMAScript 5 React Native View vs DOM 环境配置 按照React Native官方文档搭建环境 英文版搭建流程 中文版搭建流程 模拟器推荐使用Genymotion。 安装过程中可能出现的问题 $ANDROIDNDK 和 $ANDROIDHOME 没有正确设置: 解决办法：vi .bashrc和.bash_profile 加上 /usr/local/opt/android-ndk和/usr/local/opt/android-sdk,并且source一下这两个文件，然后eoch下上述两个变量是否已经存在。 真机调试 注意iOS系统真机调试需要有开发者账号 可能有些机型无法用这种方式进行(比如小米4C)，可以手动安装 结构 文件结构 代码结构 7-13: 引入需要用到的模块 15-32: 本组件的渲染逻辑 34-51: 样式定义 53: AppRegistry是JS运行所有React Native应用的入口，应用的根组件应当通过AppRegistry.registerComponent方法注册自己，然后原生系统才可以加载应用的代码包并且在启动完成之后通过调用AppRegistry.runApplication来真正运行应用 样式定义可以单独提出作为一个模块，甚至组件的具体实现也可以和应用注册分离开来 样式 React Native中用JS来写样式 所有的核心组件都接受名为style的属性。这些样式名基本上是遵循了web上的CSS的命名，只是按照JS的语法要求使用了驼峰命名法 style属性可以是一个普通的JavaScript对象，也可以是一个数组，在数组中位置居后的样式对象比居前的优先级更高 Text样式 View样式 最简单的调试方法: 当错误的书写了样式属性时，应用会抛出一个warning，在这个warning里面会列出当前元素所有可使用的样式 实际开发中组件的样式会越来越复杂，官方建议使用StyleSheet.create来集中定义组件的样式。StyleSheet提供了一种类似CSS样式表的抽象，相比于plain object，其主要有以下优势 代码质量: 移除了render里面的具体样式内容，使代码组织更加合理 给样式命名可以对render函数中的原始组件进行一种作用标记 性能角度: 创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象 它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID(现在还没实现) 因此，如果我们直接打印styles.xxx，我们只会得到一个number，要使用StyleSheet.flatten(styles.xxx)才能得到具体内容 Flex布局 在React Native中布局采用的是FleBox(弹性框)进行布局 Flex布局主要思想是让容器有能力让其子项目能够改变其宽度、高度(甚至顺序)，以最佳方式填充可用空间(主要是为了适应所有类型的显示设备和屏幕大小) 像素无关 React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点 123&lt;View style=&#123; &#123;width:100,height:100,margin:40,backgroundColor:'gray'&#125;&#125;&gt; &lt;Text style=&#123; &#123;fontSize:16,margin:20&#125;&#125;&gt;尺寸&lt;/Text&gt;&lt;/View&gt; 上面的例子，运行在Android上时，View的长和宽被解释成100dp 其单位是dp，字体被解释成16sp 其单位是sp，运行在iOS上时尺寸单位被解释称了pt，这些单位确保了布局在任何不同dpi的手机屏幕上显示不会发生改变。如果希望获取实际的像素尺寸，则需要使用尺寸 * pixelRatio。pixelRatio使用 React Native中的FlexBox 和Web CSS中的FlexBox不全相同 flexDirection: React Native中默认为flexDirection:’column’，在Web CSS中默认为flex-direction:’row’ alignItems: React Native中默认为alignItems:’stretch’，在Web CSS中默认align-items:’flex-start’ flexWrap: React Native中没有wrap-reverse，在Web CSS中有 flex: 相比Web CSS的flex接受多参数，如:flex: 2 2 10%;，但在 React Native中flex只接受一个参数 不支持属性：align-content，flex-flow等 Flex基本知识[基于RN] 父容器属性 flexDirection属性定义了父视图中的子元素沿横轴或侧轴方片的排列方式，默认为column: ‘row’, ‘column’,’row-reverse’,’column-reverse’ flexWrap属性定义了子元素在父视图内是否允许多行排列，默认为nowrap: ‘wrap’, ‘nowrap’ justifyContent属性定义了浏览器如何分配顺着父容器主轴的弹性（flex）元素之间及其周围的空间，默认为flex-start: ‘flex-start’, ‘flex-end’, ‘center’, ‘space-between’, ‘space-around’ alignItems属性以与justify-content相同的方式在侧轴方向上将当前行上的弹性元素对齐，默认为stretch: ‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’。这里需要注意，当选择stretch时，侧轴上的元素不能有固定的size，否则无效 子容器属性 alignSelf决定了元素在父元素的次轴方向的排列方式（此样式设置在子元素上），其值会覆盖父元素的alignItems的值，默认auto: ‘auto’, ‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’ flex 属性定义了一个可伸缩元素的能力，默认为0 视图边框: border[Bottom/Top/Left/Right]Width，borderColor等 尺寸: width，height 外边距: margin[Bottom/Top/Left/Right/Horizontal/Vertical]等 内边距: padding[Bottom/Top/Left/Right/Horizontal/Vertical]等 边缘: left，right，top，bottom等 定位: absolute，relative 更多参考 图片布局 图片有一个stretchMode. 通过Image.resizeMode访问，其主要有以下几种模式(默认采用cover模式): cover: 在保持图片宽高比的前提下缩放图片，直到宽度和高度都大于等于容器视图的尺寸（如果容器有padding内衬的话，则相应减去）。这样图片完全覆盖甚至超出容器，容器中不留任何空白 contain: 在保持图片宽高比的前提下缩放图片，直到宽度和高度都小于等于容器视图的尺寸（如果容器有padding内衬的话，则相应减去）。这样图片完全被包裹在容器中，容器中可能留有空白 stretch: 拉伸图片且不维持宽高比，直到宽高都刚好填满容器 repeat: 重复平铺图片直到填满容器。图片会维持原始尺寸。仅iOS可用，android使用会报错 center: 居中不拉伸 文本元素 文本可嵌套 元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着内部的元素不再是一个个矩形，而可能会在行末进行折叠 你必须把你的文本节点放在组件内。你不能直接在下放置一段文本 不能直接设置一整颗子树的默认样式。使用一个一致的文本和尺寸的推荐方式是创建一个包含相关样式的组件MyAppText，然后在你的App中反复使用它 文本标签的子树还是可以继承的，继承父元素的样式 通过numberOfLines={}可以实现文字截断效果 注意ios和android的默认文字样式是不一样的，主要是fontSize和color的不同。 参考 React Native: Bringing modern web techniques to mobile 基于Facebook Buck改造Android构建系统之初体验 flow——A static type checker for javascript 自定义 Git - Git属性 AppRegistry React Native布局详细指南 flex布局示意图 react-native 之布局篇","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://memory.lulutia.com/tags/ReactNative/"}]},{"title":"WEBGL系列之二维操作","date":"2017-06-07T03:15:45.000Z","path":"2017/06/07/webgl01/","text":"背景介绍 WebGL的技术规范继承自免费和开源的OpenGL标准[是用于渲染2D、3D矢量图形的跨语言、跨平台的API] 具体的说，WebGL是从OpenGL的一个特殊版本OpenGL ES中派生出来的，后者专用于嵌入式计算机，智能手机，家用游戏机等设备。它从OpenGL中移除了许多陈旧无用的旧特性，这使得它在保持轻量级的同时，仍具有足够的能力来渲染出精美的三维图形。 OpenGL2.0开始支持的可编程着色器方法被OpenGL ES2.0继承，成为了WebGL1.0标准的核心部分。而着色器方法或称为着色器，是使用一种类似C的编程语言实现精美的视觉效果。而编写着色器的语言称为着色器语言，WebGL使用OpenGL ES着色器语言，亦即GLSLES。 WebGL规范的建立由Khronos(也负责OpenGL规范的更新和标准化)建立的WebGL工作小组负责。2011年发布了WebGL规范的第一个版本。WebGL2.0处于Editor’s Draft状态，它主要提供与OpenGL3.0新特性的对应，现阶段它并不与WebGL1.0完全向下兼容。 基本概念 WebGL主要是用于渲染2D、3D矢量图形。在进入它的使用细节之前，我们先分析下它到底做了件什么事以及其执行的顺序。 如果你有过一点三模建模方面的经验的话，你就会知道，所有的三维模型都是由点，线，三角形构成的。譬如下面这只超级出名的bunny兔子。模型的精细程度与其面片的数量直接相关，当面片数量足够多时，人类的视觉是无法分辨三角形的。 同理，如果我们打开WebGL的绘图API，我们就会发现，它处理的也是点，线，三角形。那么它是如何由这些最基础的东西构建出整个世界的呢。其实，它主要执行了三方面的操作： 获取顶点坐标 简单图形，可以显示定义 复杂图形，一般会在三维软件导出模型时一同导出 顶点坐标会写入缓冲中等待使用 进行图元装配：即将顶点根据primitive(原始的连接关系）还原成网格结构 在WebGL中，为了使用者对顶点的位置有足够的控制权，提供了一个顶点着色器的东西。它是用上面提到的opengl es编写的，然后以字符串的形式嵌入在js文件中的，在程序开始运行前就已经设置好了 顶点着色器中主要对点的特性进行处理，比如进行坐标的转换等，然后由GPU执行图元装配。此处是以单个点为单位执行的操作，有多少个点，这段程序就会执行多少次 12345var VSHADER_SOURCE = 'void main() &#123;\\n' +'gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n' + //设置坐标，必须'gl_PointSize = 10.0;\\n' + // 设置尺寸，非必需，默认1.0'&#125;\\n'; 进行光栅化：将图转化为一个个栅格组成的图象 上面一部生成了模型的网格形态，但是要呈现实际的模型还需要“着色”，这部分WebGL也为我们提供了片元着色器来进行控制。 片元着色器主要进行材质，颜色的处理等，它会进行逐片元处理过程，片元这边可大概理解为像素(图像的单元) 1234 var FSHADER_SOURCE = 'void main() &#123;\\n' +'gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n' + // 设置颜色'&#125;\\n'; 下面图示为整体流程: GLSE中的数据类型 基本类型 float: 表示浮点数 int： 整型 bool： 布尔类型 齐次坐标: (x, y, z, w) 等价于三维坐标 (x/w, y/w, z/w)，w必需大于等于0，齐次坐标的存在，使得用矩阵乘法来描述顶点变换称为可能，三维图形系统在计算过程中，通常使用齐次坐标来表示顶点的三维坐标，这样能够提高处理三维数据的效率 矢量和矩阵 vec4: 表示由四个浮点数组成的矢量，类似有 vec2,vec3,ivec2,ivec3,ivec4,bvec2,bvec3,bvec4 mat2: 表示22的浮点数元素的矩阵，类似有 mat3,mat4, 注意*列主序 结构体 使用struct，将已存在的类型聚合到一起，就可以定义为结构体 数组 只支持一维数组，而且数组对象不支持pop()和push()等操作 取样器(纹理)：必须通过该类型变量访问纹理，两种基本的取样器类型如下 sampler2D samplerCube 注意：取样器变量只能是uniform变量，或者需要访问纹理的函数 函数 1234返回类型函数名(type0, arg0, type1, arg1, ...typen, argn) &#123; 函数计算 return 返回值&#125; 存储限定字 const: 不可变 attribute: 只能出现在顶点着色器中，只能被声明为全局变量，被用来表示逐点的信息 uniform：可以用在顶点和片元着色器中，必须是全局变量，uniform变量是只读的，它可以是数组和结构体之外的任意类型，它包含了“一致”[即非逐顶点／片元的]的数据 varying: 必须全局，从顶点着色器向片元着色器传输数据，在两个着色器中必须同名同类型 精度限定字 highp: 高精度 mediump: 中精度 lowp: 低精度 可以使用关键字precision来声明着色器的默认精度，这行代码必须在顶点着色器或片元着色器的顶部，格式为precision 精度限定字 类型名称 注意：片元着色器中的float类型没有默认精度，需要手动指定，否则会出现编译错误 预处理指令 预处理指令用来在真正编译之前对代码进行预处理，都以#开始 核心思想 获取WebGL上下文： 123var canvas = document.getElementById('example');var ctx = canvas.getContext('2d');ctx.fillStyle = 'rgba(0, 0, 255, 1.0)'; 初始化着色器： 详细见具体API 1-13部分，具体流程如下: 设置canvas背景色并清除canvas： 12345// 设定背景色，一旦指定了背景色后，背景色就会常驻WebGL系统，在下一次再调用这个函数前不会改变gl.clearColor(0.0, 0.0, 0.0, 1.0); //见API 15// 用背景色清空canvas绘图区域，此方法继承自OpenGL，基于多基本缓冲区模型清空绘图区域，实际上是在清空颜色缓冲区，类似的还有 gl.DEPTH_BUFFER_BIT,gl.STENCIL_BUFFER_BITgl.clear(gl.COLOR_BUFFER_BIT); // 见API16 右手坐标系是WebGL默认的坐标系统 JS与着色器之间传输数据(以attribute举例) 详细见具体API 17-20部分，具体流程如下: 动态传输例子点我, 点我 缓冲区对象 WebGL提供了缓冲区对象，它可以一次性的向着色器传入多个顶点的数据。使用缓冲区对象向顶点着色器传入多个顶点数据的步骤如下: 详细见具体API 21-25部分，注意可以创建多个缓冲区对象 WebGL可绘制的基本图形，主要运用于API 14，对比例子点我 WebGL可以绘制gl.POINTS, gl.LINES, gl.LINE_STRIP, gl.LINE_LOOP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN 七种，它们的绘制顺序如下： 移动、旋转、缩放 对于平移而言，就是对顶点的每个分量加上其在对应轴上平移的距离, 因此就是在顶点着色器中对原有的position加上移动的position即可 123newX = oldX + moveX;newY = oldY + moveY;newZ = oldZ + moveZ; 对于旋转而言，有公式如下[绕Z轴旋转]，因此将顶点着色器中的坐标换为下面的计算即可：注意JS内置的Math.cos()和Math.sin()接受的是弧度制，而并非角度 123newX = oldX * cosβ - oldY * sinβnewY = oldX * sinβ + oldY * cosβnewZ = oldZ 123456'void main() &#123;\\n' +'gl_Position.x = a_Position.x * u_CosB - a_Position.y * u_SinB;\\n' + //设置坐标，必须'gl_Position.y = a_Position.x * u_SinB + a_Position.y * u_CosB;\\n' +'gl_Position.z = a_Position.z;\\n' + 'gl_Position.w = 1.0;\\n' +'&#125;\\n'; 当情况复杂起来后，需要进行矩阵变换，比如根据上面可以得到平移矩阵，旋转矩阵和缩放矩阵如下：之后将它与坐标相乘即可得到变换后的坐标,因为矩阵计算比较复杂，一般情况下都使用封装好的矩阵操作库进行计算 1gl_Position = u_xformMatrix * a_Position ; 动画 根据不同时间确定不同的状态 在每次绘制前，清除上次绘制的内容，并绘制相应状态下的图形 调用requestAnimationFrame(fn)进行持续绘制 颜色之前的所有例子我们都是直接设定了颜色值并传入片元着色器，其颜色值是统一的不变的，但是实际中，我们可能会对不同的点着色不同，因此顶点着色器与片元着色器之间应该有某种联系 实际在顶点着色器与片元着色器中主要执行了两个步骤： 图形装配过程：将孤立的顶点坐标装配成几何图形 光栅化过程：将装配好的几何图形转化为片元 光栅化过程中生成的片元都是带有坐标信息的，调用片元着色器时这些坐标信息也随着片元传了进来，可以通过片元着色器中的内置变量来访问片元的坐标 在WebGL中，如果顶点着色器与片元着色器中有类型和命名都相同的varying变量，那么顶点着色器赋给该变量的值就会自动被传入片元着色器，但是，片元着色器中的v_Color变量和顶点着色器中的v_Color实际并不是一回事，顶点着色器中的v_Color变量在传入片元着色器之前经过了内插过程，所以称为varying 整个颜色的处理过程如下： 纹理 真实世界中的颜色变化是相当细粒度的，我们如果全部通过自己定义来做则会陷入无休止的工作中，因此在三维图形学中，纹理映射就成为了一项关键技术。所谓纹理映射，就是将一张图像映射到一个几何图形的表面上去，它根据纹理图像，为之前光栅化后的每个片元涂上合适的颜色，其中组成纹理图像的像素称为纹素，其具体流程如下： 在执行纹理映射的过程中，会涉及到纹理坐标，WebGL系统中的纹理坐标是二维的，使用st坐标系统。其坐标值与图像自身的尺寸无关，左下角的坐标为(0.0, 0.0), 右下角为(1.0, 0.0), 右上角为(1.0, 1.0), 左上角为(0.0, 1.0)。纹理映射需要顶点着色器和片元着色器的配合，首先在顶点着色器中为每个顶点指定纹理坐标，然后在片元着色器中根据每个片元的纹理坐标从纹理图像中抽取纹理像素颜色。 详细流程见API 27-32，具体代码处理流程如下：在GLSE中运用texture2D(sample2D, sampler, vec2, coord): 来从sample指定的纹理上获取coord指定的纹理坐标处的像素颜色, 修改纹理坐标和映射方式点我, 多重纹理点我 具体API注：文中demo根据WebGL编程指南demo改编而来 gl.createShader(type): 创建由type指定的着色器对象，type的值分别为gl.VERTEX_SHADER表示顶点着色器 gl.FRAGMENT_SHADER表示片元着色器 gl.shaderSource(shader, source): 将source指定的字符串形式的代码传入shader指定着色器，如果之前已经向shader传入过代码了，旧的代码将会被替换掉 gl.compileShader(shader): 编译shader指定的着色器中的源代码 gl.getShaderParameter(shader, pname): 获取shader指定的着色器中，pname指定的参数信息pname: 指定待获取参数的类型，可以是gl.SHADER_TYPE gl.DELETE_STATUS或者gl.COMPILE_STATUS，根据pname的不同，返回不同的值 gl.getShaderInfoLog(shader): 获取shader指定的着色器的信息日志 gl.deleteShader(shader): 如果不需要这个着色器，可以用gl.deleteShader()函数来删除着色器，注意，如果着色器对象还在使用，那么deleteShader()并不会立刻删除着色器而是要等到程序对象不再使用该着色器后，才将其删除 gl.createProgram(): 创建程序对象 gl.attachShader(program, shader): 将shader指定的着色器对象分配给program指定的程序对象，着色器在附给程序对象前，并不一定要为其指定代码或进行编译(也就是说，把空的着色器附给程序对象也是可以的) gl.linkProgram(program): 连接program指定的程序对象中的着色器进行这一步的目的是确保： 顶点着色器和片元着色器的varying变量同名同类型，且一一对应 顶点着色器对每个varying变量赋了值 顶点着色器和片元着色器中的同名uniform变量也是同类型的 着色器中的attribute变量，uniform变量和varying变量的个数没有超过着色器的上限 gl.getProgramParameter(program, pname): 获取pname指定的程序对象中pname指定的参数信息。返回值随着pname的不同而不同pname：gl.DELETE_STATUS gl.LINK_STATUS gl.VALIDATE_STATUS gl.ATTACHED_SHADERS gl.ACTIVE_ATTRIBUTES gl.ACTIVE_UNIFORMS, 根据pname的不同，返回值不同, 程序对象即使连接成功了，也有可能运行失败，比如没有为取样器分配纹理单元。这些错误是在运行阶段而不是连接阶段产生的 gl.getProgramInfoLog(program): 获取program指定的程序对象的信息日志 gl.deleteProgram(program): 删除程序对象 gl.useProgram(program): 告知WebGL系统绘制时使用program指定的程序对象 gl.drawArrays(mode, first, count): 按照mode参数指定的方式绘制图形(gl.POINTS, gl.LINES, gl.LINE_STRIP, gl.LINE_LOOP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN), first: 指定从哪个顶点开始绘制 整型, count: 指定绘制多少个点 整型 gl.clearColor(red, green, blue, alpha): 确定当清除颜色buffer时使用的颜色 gl.clear(mask): 指定被清除的buffer，可能的值gl.COLOR_BUFFER_BIT，gl.DEPTH_BUFFER_BIT，gl.STENCIL_BUFFER_BIT gl.getAttribLocation(program, name): 获取由name参数指定的attribute变量的存储地址, program: 指定包含顶点着色器和片元着色器的着色器程序对象, name: 指定想要获取其存储地址的attribute变量的名称 gl.vertexAttrib3f(location, v0, v1, v2): 将数据(v0, v1, v2)传给由location参数指定的attribute变量, gl.vertexAttribXf是一系列同族函数，其中X可以为1，2，3，4，无论哪一个，第四个值都为1.0，其他未填位填充0.0, gl.vertexAttribXv是其矢量版本，接受类型化数组, gl.vertexAttrib 基础函数名 x 参数个数 v参数类型 还能够有gl.vertexAttrib[123]f这种用法 gl.getUniformLocation(program, name): 与API17类似 gl.uniform[1234][fi]v: 与API18类似 gl.createBuffer(): 创建缓冲区对象, 这一步的结果是WebGL系统中多了一个新创建出来的缓冲区对象 gl.bindBuffer(target, buffer): 允许使用buffer表示的缓冲区对象并将其绑定到target表示的目标上，target: gl.ARRAY_BUFFER 表示缓冲区对象中包含了顶点的数据，gl.ELEMENT_ARRAY_BUFFER表示缓冲区对象中包含了顶点的索引值，buffer: 指定之前由gl.createBuffer()返回的待绑定的缓冲区对象将缓冲区对象绑定到目标。这个目标表示缓冲区对象的用途, 我们不能直接向缓冲区写入数据，而只能向目标写入数据，所以要向缓冲区写入数据，必须先绑定。 gl.bufferData(target, ArrayBufferView srcData, usage): 这个API在WebGL1.0和2.0上有所不同，具体见规范。总的来说是开辟存储空间，向绑定在target上的缓冲区对象写入数据data gl.vertexAttribPointer(index, size, type, normalized, stride, offset): 将绑定到target的缓冲区对象分配给由location指定的attribute变量, size: 指定缓冲区中每个顶点的分量个数(1-4), type: 指定数据格式 [gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT], normalized: 传入true, false表明是否将非浮点数的数据归一化到[0, 1]或[-1, 1]区间, stride: 指定相邻两个顶点间的字节数，默认0, offset: 指定缓冲区对象中的偏移量(以字节为单位) gl.enableVertexAttribArray(index): 开启index指定的attribute变量，链接变量与分配给它的缓冲区对象，使顶点着色器能够访问缓冲区内的数据 gl.uniformMatrix[234]x[234]fv(location, transpose, array…): 将array表示的n*n矩阵分配给由location指定的uniform变量，transpose在WebGL中必须指定为false gl.createTexture(): 创建纹理对象以存储纹理图像 gl.pixelStorei(pname, param): 使用pname和param指定的方式处理加载得到的图片, pname:gl.UNPACK_FLIP_Y_WEBGL: 对图像进行Y轴反转，默认为false; gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL: 将图像RGB颜色值的每一个分量乘以A，默认为false, param: 指定非0(true)或0(false)，必须为整数。使用原因：WebGL纹理坐标系统中t轴的方向和PNG,BMP,JPG等格式图片的坐标系统的Y轴方向是相反的，所以要对纹理图像进行Y轴反转 gl.activeTexture(texture): 激活texture指定的纹理单元 gl.bindTexture(target, texture): 开启texture指定的纹理对象，并将其绑定到target上, 如果已经激活了某个纹理单元，则纹理对象也会绑定到这个纹理单元上; target: gl.TEXTURE_2D gl.TEXTURE_CUBE_MAP;在WebGL中，没法直接操作纹理对象，必须通过将纹理对象绑定到纹理单元上，然后通过操作纹理单元来操作纹理对象 gl.texParameterfi: 将param的值赋给绑定到目标的纹理对象的pname参数上, 具体参数见规定，通常可以不用调用，使用默认值就可以了 gl.texImage2D(target, level, internalformat, format, type, image): 将image指定的图像分配给绑定到目标上的纹理对象","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"2017你好～","date":"2017-01-08T12:51:32.000Z","path":"2017/01/08/2017HELLO/","text":"又一年匆匆走过，这一年说长不长说短不短，但的的确确发生了好多好多事情。先来篇流水帐总结。 被老爹说了n久的驾照终于到手了，并且拿到的第二天就被老爹像拎兔子一样拎出去开了70多公里。 和老爸因为一件现在显而易见已经完全想不起来的事情起了争执，一气之下把齐腰长发剪成了个短的不能再短的发型，完美开启了假小子模式。 回学校后顺利结束了答辩，在等资料处理的漫长的一个月里拉着大鸟去日本走了一遭。在这只有零星早樱的季节吃了超级好吃的美食，看了超级棒的风景，遇见了超级有爱的人，也算满足了小时候的心愿。意大利和日本这两个我在小学毕业写在同学录 最想去的国家 一栏的国家都GET。 之后被老哥约着去菲律宾潜水，计划之外的拿到了初级潜水执照，看到了不一样的风景却依然没有学会游泳，泪目。 4月，繁忙的一个月。拽着啊呜和麦子在陌生的帝都陪我找房子，感受就是贵贵贵……尘埃落定后去广州见了下快五年没见的小燕子～虽然这么久没见平时也没啥联系，但原来的感觉在见面的那刻还是回来了。之后作死的和啊呜去了柬埔寨，三天暴走，看过了千年的文明，也晒的跟块煤炭一样了…… 终于的终于还是入职了，然后就入了RN大坑，痛并快乐着的痛快啊。同事都特别好，毕竟年纪差的不多，玩到一块儿没障碍。去了没看见草的草原，漂了比想象中短的水道，爬了只能看见雾霾的山，为了烤鱼来回三四个小时 ｜ 果然吃货技能点的太高。 有些时候会觉得自己好挫，但貌似这个事情急也没用，只能一步一个脚印来。 七月和麦子看了仙剑一的舞台剧，感觉已经记不起上次看舞台剧是多久了，总之其现在的先进程度还是远远超过了我的预期的（也许是我期待值真心太低了 本来约好和科儿的中秋青岛游因为啊呜的突然到来而取消了，不过来了场说走就走的旅行去了趟兰卡威……人生中第二次进警察局，同时深深的体会到自驾的重要性…… 国庆先去上海见了科儿，接着和两只萌萌的室友一起从杭州去了趟越南，对于给小费的事情咱都完美的坚持了我们的底线，棒棒的，120个赞。这趟旅游重要的不是去哪里而是和谁去～ 16年的最后，集结了浩浩荡荡十多号人一起去东北跨年！零点时刻，我们五只吃着毛肚喝着酒或饮料，就这样毫无防备的被拖入了2017。 你好啊，2017。 PS：自己挖的一大堆坑还是希望能在2017填一填哈，啥日语啊，啥乌克丽丽啊，啥天文观测啊，啥无人机啊 （好吧，发现缺钱是硬伤，好好工作好好赚钱，好好和我爱的人和爱我的人一起过好每一天～","tags":[{"name":"总结","slug":"总结","permalink":"http://memory.lulutia.com/tags/总结/"}]},{"title":"yeoman建立脚手架","date":"2015-11-03T14:10:00.000Z","path":"2015/11/03/yeoman建立脚手架/","text":"首先你要先安装yeoman，npm install -g yo bower grunt-cli gulp。 generator是一个Node.js的模块。 建立一个写generator的文件，必须命名为generator-name(name是自己取)。比如我建立一个generator-lulutia-react。 npm init来建立一个package.json。 123456789101112131415161718 &#123; \"name\": \"generator-lulutia-react\",//必须generator开头 \"version\": \"0.0.1\", \"description\": \"the bone to build a app\", \"files\": [ \"app\", \"router\" ],//必须是你的generator用到的文件构成的数组 \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [ \"yeoman-generator\"//必须有这条 ], \"author\": \"lulutia\", \"license\": \"MIT\"&#125; npm install yeoman-generator --save//yeoman的依赖必须是最新的 默认执行yo name时执行的是app内的内容，yo name:subcommand执行的是其他文件夹里的内容。 yeoman提供两种组织方式来，其一是:./,其二是:generators/，注意第二种方式的package.json内的files要相应修改。 根据提供的基本结构来写自己的脚手架内容 12345678910111213var generators = require('yeoman-generator');module.exports = yeoman.generators.Base.extend(&#123;// The name `constructor` is important hereconstructor: function () &#123;// Calling the super constructor is important so our generator is correctly set upgenerators.Base.apply(this, arguments);// Next, add your custom codethis.option('coffee'); // This method adds support for a `--coffee` flag&#125;&#125;); 我这里用了几个库，Prompts:主要掌管generator与用户的交互 1234567891011121314module.exports = yeoman.generators.Base.extend(&#123;prompting: function () &#123;var done = this.async();this.prompt(&#123; type : 'input', name : 'name', message : 'Your project name', default : this.appname // Default to current folder name&#125;, function (answers) &#123; this.log(answers.name); done();&#125;.bind(this));&#125;&#125;) writing里面用mkdirp建立基本骨架。在app内部建立templates文件夹，通过里面的文件的拷贝建立结构。 1234567mkdirp(\"assets/style\");mkdirp(\"build\"); this.fs.copy( this.templatePath('coffeelint.json'), this.destinationPath('coffeelint.json') ); generator.installDependencies()安装依赖. 在generator-name/文件夹下运行npm link可以使generator在本地可用。 意料之外的问题 yeoman安装的时候表示node和npm的版本都落后了，然后npm这个命令就无法用了……简直了＝＝然后想用brew安装下，结果忘记brew没更新，各种更新无效。 直接用curl -L https://www.npmjs.com/install.sh | sh加上sudo也有问题，还是报权限错误。 决定可以用bower，但强迫症患者觉得这样不完美。可以直接重新下node，但觉得代价太大。 用了比较粗暴的方法，去npm 的github上下载了sh，然后sudo sh /Users/muriel/Downloads/install.sh来安装。完了顺便把brew更新下,把没升级的软件升级了brew update;brew upgrade;brew cleanup。 然后又出来一个问题，npm install按照package.json来安装但是目录结构有问题，原来npm的3开始决定采用扁平化处理，所以之前的代码为了适应这个改变必须要做一些改变。 具体代码","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"ES6 learning 五","date":"2015-11-02T13:36:00.000Z","path":"2015/11/02/ES6-5/","text":"异步操作和Async函数 ES6之前，异步编程的几种方式： 回调函数 事件监听 发布/订阅 Promise对象 其他：Generator函数，Thunk函数。可以用thunkify模块，结合Generator函数，封装一个run函数实现自动化流程管理。co模块(使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象)。async函数，async函数就是Generator函数的语法糖，它的自动执行器不需要用户自己来实现。 感觉上async最好用： 1234567891011async function chainAnimationsAsync(elem, animations) &#123; var ret = null; try &#123; for(var anim of animations) &#123; ret = await anim(elem); &#125; &#125; catch(e) &#123; /* 忽略错误，继续执行 */ &#125; return ret;&#125; Class 类的内部所有定义的方法，都是不可枚举的（enumerable）。 constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 Class表达式：采用Class表达式，可以写出立即执行的Class。 12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;;//需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 Class不存在变量提升。 继承：class ColorPoint extends Point {} super关键字，指代父类的实例(即父类的this对象)。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 子类的proto属性，表示构造函数的继承，总是指向父类。子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（proto属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。 Object.getPrototypeOf方法可以用来从子类上获取父类。 子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。通过子类实例的proto.proto属性，可以修改父类实例的行为。 ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。 存值函数和取值函数是设置在属性的descriptor对象上的。 父类的静态方法，可以被子类继承。 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。ES6明确规定，Class内部只有静态方法，没有静态属性。 ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。子类继承父类时，new.target会返回子类。 Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。 修饰器 修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。 1234567@decoratorclass A &#123;&#125;// 等同于class A &#123;&#125;A = decorator(A) || A; 修饰器不仅可以修饰类，还可以修饰类的属性。修饰器有注释的作用。 由于存在函数提升，使得修饰器不能用于函数。 一些常用的库：core-decorators.js, traits-decorator… Module 模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 export语句输出的值是动态绑定，绑定其所在的模块。 ES6支持多重加载，即所加载的模块中又加载其他模块。 import命令具有提升效果，会提升到整个模块的头部，首先执行。 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 module命令可以取代import语句，达到整体输入模块的作用。module命令后面跟一个变量，表示输入的模块定义在该变量上。 export default命令，为模块指定默认输出。使用export default时，对应的import语句不需要使用大括号；不使用export default时，对应的import语句需要使用大括号。一个模块只能有一个默认输出，因此export deault命令只能使用一次。 模块之间也可以继承。 一些常用的库：ES6 module transpiler, SystemJS 编程风格 let取代var 在let和const之间，建议优先使用const，let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的。 严格模式 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 使用数组成员对变量赋值，优先使用解构赋值。 函数的参数如果是对象的成员，优先使用解构赋值。 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 使用扩展运算符（…）拷贝数组。 使用Array.from方法，将类似数组的对象转为数组。 立即执行函数可以写成箭头函数的形式。 那些需要使用函数表达式的场合，尽量用箭头函数代替。 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 使用默认值语法设置函数参数的默认值。 注意区分Object和Map，只有模拟实体对象时，才使用Object。如果只是需要key:value的数据结构，使用Map。因为Map有内建的遍历机制。 总是用class，取代需要prototype操作。 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 使用export取代module.exports。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 如果模块默认输出一个函数，函数名的首字母应该小写。如果模块默认输出一个对象，对象名的首字母应该大写。","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"ES6 learning 四","date":"2015-10-23T12:22:00.000Z","path":"2015/10/23/ES6-4/","text":"Iterator和for..of循环 Iterator的作用有三个： 一是为各种数据结构，提供一个统一的、简便的访问接口； 二是使得数据结构的成员能够按某种次序排列； 三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。 在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。调用Symbol.iterator方法，就会得到当前数据结构默认的遍历器生成函数。 字符串是一个类似数组的对象，也原生具有Iterator接口。 JavaScript原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值。Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。 对于字符串来说，for…of循环还有一个特点，就是会正确识别32位UTF-16字符。 对于普通的对象，for…of结构不能直接使用，会报错，必须部署了iterator接口后才能使用。一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。另一个方法是使用Generator函数将对象重新包装一下。 for…in循环主要是为遍历对象而设计的，不适用于遍历数组。 Generator函数 Generator函数是ES6提供的一种异步编程解决方案,Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 Generator函数是一个普通函数，但是有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。yield语句不能用在普通函数中，否则会报错。yield语句如果用在一个表达式之中，必须放在圆括号里面。yield语句用作函数参数或赋值表达式的右边，可以不加括号。for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象。 如果Generator函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。如果Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历，否则遍历直接终止。但是，如果使用throw命令抛出错误，不会影响遍历器状态。 如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。 yield*语句，用来在一个Generator函数里面执行另一个Generator函数。 可以并行执行、交换执行权的线程（或函数），就称为协程。如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。 Promise对象 所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。 Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。 Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise实例具有then方法，也就是说，then方法是定义在原型对象,then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。采用链式的then，可以指定一组按照次序调用的回调函数。 Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"ES6 learning 三","date":"2015-10-22T02:09:00.000Z","path":"2015/10/22/ES6-3/","text":"对象的扩展 ES6允许在对象之中，只写属性名。这时，属性值等于属性名所代表的变量。除了属性简写，方法也可以简写。 ES6允许字面量定义对象时，用表达式作为对象的属性名或方法名，即把表达式放在方括号内。注意，属性名表达式与简洁表示法，不能同时使用，会报错。 Object.is用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。Object.assign只拷贝自身属性，不可枚举的属性（enumerable为false）和继承的属性不会被拷贝。 对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 proto属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。 Object.observe()，Object.unobserve()。 目前，ES7有一个提案，将rest参数/扩展运算符（…）引入对象。 Symbol ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。 Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。let s=Symbol();。 Symbol值不能与其他类型的值进行运算，会报错。但是，Symbol值可以显式转为字符串。 注意，Symbol值作为对象属性名时，不能用点运算符。同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。 Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和Symbol键名。 Symbol.for方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。Symbol.keyFor方法返回一个已登记的Symbol类型值的key。 Symbol.hasInstance, Symbol.isConcatSpreadable,Symbol.replace,Symbol.search,Symbol.split,Symbol.iterator,Symbol.toPrimitive,Symbol.toStringTag,Symbol.unscopables Proxy和Reflect Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。将Object对象的一些明显属于语言层面的方法，放到Reflect对象上。 Set Map Set,它类似于数组，但是成员的值都是唯一的，没有重复的值。Set内部判断两个值是否不同，使用的算法类似于精确相等运算符（===），这意味着，两个对象总是不相等的。 Array.from方法可以将Set结构转为数组。 由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。 WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。首先，WeakSet的成员只能是对象，而不能是其他类型的值。其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。 ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 set方法返回的是Map本身，因此可以采用链式写法。 WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。 WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"ES6 learning 二","date":"2015-10-21T14:16:00.000Z","path":"2015/10/21/ES6-2/","text":"字符串的扩展 JavaScript可以用\\uxxxx表示一个字符，但局限于\\u0000–\\uFFFF,超过就得用双字节。ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 1\"\\u&#123;20BB7&#125;\" // \"𠮷\" JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。charAt方法无法读取字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。它的逆过程通过String.fromCodePoint实现，弥补了String.fromCharCode的溢出问题。 12charCodeAt -&gt; codePointAtString.fromCharCode -&gt; String.fromCodePoint for..of遍历字符串，可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 ES7提供了字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。 ES6提供String.prototype.normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 includes(),startsWith(),endsWith(),repeat() 模板字符串：模板字符串（template string）是增强版的字符串，用反引号（`）标识。如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。模板字符串中嵌入变量，需要将变量名写在${}之中。使用&lt;%= … %&gt;输出JavaScript表达式。 标签模板：模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 数值的扩展 ES6提供了二进制和八进制数值的新的写法，分别用前缀0b和0o表示。 Number.isFinite(),Number.isNaN() 区别于全局的isFinite()与isNaN()，他们不调用Number()方法进行转换。 Number.parseInt(),Number.parseFloat() Number.isInterger(),Number.EPSILON Number.MAX_SAFE_INTERGER,Number.MIN_SAFE_INTERGER,Number.isSafeInteger() Math新增的方法： Math.trunc()//去除小数部分，返回整数部分 Math.sign()//判断一个数到底是正数，负数，还是0 Math.cbrt()//计算一个数的立方根 Math.clz32()//Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0 Math.imul()//Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。主要解决的精度问题。 Math.fround()//返回一个数的单精度浮点数形式 Math.hypot()//返回所有参数的平方和的平方根 Math.expm1(),Math.log1p(),Math.log10(),Math.log2() Math.sinh(x),Math.cosh(x),Math.tanh(x),Math.asinh(x),Math.acosh(x),Math.atanh(x) ES7新增了一个指数运算符（）,```2 3 = 222```。 数组的扩展 Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 扩展运算符（…）也可以将某些数据结构转为数组,var args = [...arguments];。 Array.of方法用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。只有当参数个数不少于2个，Array()才会返回由参数组成的新数组。 copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 find()//直接返回数组元素；findIndex()//返回数组元素索引 fill方法使用给定值，填充一个数组。 数组实例的entries()，keys()和values()。 数组实例的includes()。 注意对数组的空位的处理变化了。 数组推导[超级赞的功能] Array.observe(),Array.unobserve()这两个方法用于监听（取消监听）数组的变化，指定回调函数。 函数的扩展 ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。参数默认值所处的作用域，不是全局作用域，而是函数作用域。参数变量是默认声明的，所以不能用let或const再次声明。 ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。所有数组特有的方法都可以用于这个变量。注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。函数的length属性，不包括rest参数。 扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。 函数的name属性，返回该函数的函数名。bind返回的函数，name属性值会加上“bound ”前缀。 ES6允许使用“箭头”（=&gt;）定义函数。 函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。由于this在箭头函数中被绑定，所以不能用call()、apply()、bind()这些方法去改变this的指向。 不可以当作构造函数。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 函数绑定:函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。由于双冒号运算符返回的还是原对象，因此可以采用链式写法。 尾调用:指某个函数的最后一步是调用另一个函数。“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。 ES7有一个提案，允许函数的最后一个参数有尾逗号（trailing comma）。","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"JavaScript中的delete一探","date":"2015-10-20T04:36:00.000Z","path":"2015/10/20/JavaScript-delete/","text":"核心内容借鉴自下面的网址 delete一般用法： 删除对象的属性 1234var a=&#123;p:21&#125;;console.log(a.p);//21delete a.p;//trueconsole.log(a.p);//undefined 无法删除一般的变量 1234var x=13;console.log(x);//13delete x;//falseconsole.log(x);//13 无法删除函数 123var p=function()&#123;&#125;;delete p;//falsetypeof(p);//function 造成上述表现的原因 在ECMAScript中，有三种可执行代码类型：全局代码、函数代码、eval代码。对于以上几种代码都有相应的执行上下文。每个执行上下文又对应有变量对象，在源代码中声明的变量和方法实际上都是作为属性被加入到与当前上下文相关联的这个对象当中。 全局代码时：变量对象是全局对象。 1234567891011121314151617181920212223242526 var global=33; window.global;//33 global===window.global;//true function uu()&#123;&#125;; typeof window.uu;//&quot;function&quot; window.uu===uu;//true ``` * 函数代码：此时有活动对象的概念。**在函数段中，并不是只有显式声明的变量和函数会成为活动对象的属性，对于每个函数中隐式存在的arguments对象（函数的参数列表）也是一样的**。 * eval函数：进入eval代码时并不会新建新的变量对象，而是沿用当前的环境。* 每一个变量属性都可以有以下任意多个属性: ReadOnly, DontEnum, DontDelete, Internal。在声明变量或者函数时，他们都变成了当前上下文对象的属性，这些属性在创建时 都带有DontDelete标记；但是显式或者隐式的赋值语句所产生的属性并不会带有这个标记。 ```JavaScript:var test=1;delete test;//falsetest2 = 2;delete test2;//true``` * 一些内建的对象是自动持有DontDelete这个标记的，从而不能被删除，比如函数内的arguments，函数的传入参数以及函数的length属性。* 属性标记诸如DontDelete是在这个属性被创建的时候 产生的，之后对该属性的任何赋值都不会改变此属性的标记。```JavaScript:function y()&#123;&#125;;delete y;//falsey=1;delete y;//falsetypeof y;//&quot;number&quot; 在eval中声明的变量创建时都不会带有DontDelete标记,在函数内部也一样。 12eval(&apos;var ii=34;&apos;);delete ii;//true 在Firebug控制台中的代码最终将通过eval执行，而不是作为全局代码或函数代码。 IE6-8中的问题： 通过全局this变量去删除属性(delete this.x)总会出错 直接删除该属性(delete x)时： 如果x是通过全局this赋值产生会(this.x=1)导致错误； 如果x通过显式声明创建(var x=1)则delete会像我们预料的那样无法删除并返回false； 如果x通过非声明式赋值创建(x=1)则delete可以正常删除。 原因： “IE的全局变量对象是通过JScript实现，而一般的全局变量是由host实现的。” 对于宿主对象而言，delete操作的结果是不可预料的。因为宿主对象根据不同浏览器的实现允许有不同的行为，这其中包括了delete。 strict mode采用了更主动并且描述性的方法，而不是简单的忽略无效的删除操作。(比如平常删除一个不存在的变量会return true;但使用严格模式后会报错。)","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"面试回忆360","date":"2015-10-15T12:38:00.000Z","path":"2015/10/15/memory1/","text":"一大早就跑南京去面360，完全高铁当公交的节奏……但是，我穷啊＝＝。总的来说面的特别的不好，还不是自己弱，怪谁啊，稍微纪录下吧。 岗位：web前端工程师 笔试题还记得吗？ 会哪些语言？ 啥叫面向对象？ 算法和数据结构怎么样？ 用JavaScript手写一个排序。 学过哪些课程？这个课程教了些啥？ 操作系统熟吗？ 计算机如何实现减法的？ 数据库熟吗？了解哪些数据库？ 说一下数据库范式？ 说一下tcp/IP分层模型。 说一下tcp三次握手协议。 说一下应用层中的协议对应的网络层的协议。 在TCP/IP协议中如何实现的IP的映射。 说一下对JavaScript原型链的理解。 用代码实现js中的继承。 说一下对闭包的理解。让写程序实现一个计时器每隔一秒按顺序输出1-60中的一个值。 说一下对作用域的理解，然后给了个程序，问输出。 ECMAScript有哪些新变化。 ECMAScript5最近加了哪些属性。 现在主流的是ECMAScript几。 如何理解html的语义化。 css的选择器有哪些？ 有哪些行内元素标签？ 一行两个div，第一个固宽，用css实现后面的自适应。 实现知道长宽的div的垂直居中。 问了些项目相关。 ————————————————————————————————————————————————————————————————总的感觉是他们希望招全栈工程师，当然我自己弱也是事实，os的确没系统的学过，数据库和网络学的太久远了忘记的差不多了，c++那些快两年没用过了也是退化的很严重啊。当然之前没想到前端会面这些所以也没系统的复习＝＝打算工作决定后用接下来的半年好好系统的整理下整个计算机的知识，维护一个完整的知识网络。因为觉得这个还是很重要的一件事情。最后提问阶段，我问了两个问题： 其一，刚才面试问的很宽泛，问题还没说完，面试官来了一句：我不问你这些问你哪些……，（其实我想说的是他们怎么看待重要性的问题的……）伤不起。 知趣的问第二个问题，你们那边主要用什么技术，面试官来了一句：还不就是那一套……（我真心没法描述我当时心里的状况）……我接着说比如node这些会涉及吗？他来了句当然会涉及各种技术，比如可能进去会写PHP啊，总之大概意思就是全栈是趋势blabla。 嘛～只能说不适合啰；我对计算机基础知识的掌握达不到面试官的要求，同样面试官对我提问的回答也达不到我的预期。不过还是给学校丢人了(大哭状)","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"面试","slug":"面试","permalink":"http://memory.lulutia.com/tags/面试/"}]},{"title":"(数据结构与算法JavaScript描述)读书笔记","date":"2015-10-13T08:06:00.000Z","path":"2015/10/13/note-structure01/","text":"数组 判断是否数组：Array.isArray(sth); []创建数组的效率比Array构造函数高; 浅复制 VS 深复制； 字符串生成数组:split();数组的字符串表示:join()/toString() sort()是按照字典顺序对元素进行排序的，因此它假定元素都是字符串类型的，按照数字大小进行排序的一般如下： 12345function compare(num1,num2)&#123; return num1 - num2;&#125;var nums = [3,2,5,7,88];nums.sort(compare); 迭代器方法: forEach();every();some();reduce()–累加；reduceRight();map();filter()–返回一个新数组，该数组包含应用该函数后结果为true的元素; 创建多维数组的一般办法 1234567891011function matrix(numrows,numcols,initial)&#123; var arr = []; for(var i = 0; i &lt; numrows; i++)&#123; var columns = []; for(var j = 0; j &lt; numcols; j++)&#123; columns[j] = initial; &#125; arr[i] = columns; &#125; return arr;&#125; 列表 如果数据结构非常复杂。列表的作用就没有那么大了。 如果数据储存的顺序不重要，也不必对数据进行查找，那么列表就很好。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798function List()&#123; this.listSize = 0;//列表长度 this.pos = 0;//列表的当前位置 this.dataStore = [];//初始化一个空数组来保存列表元素 this.clear = clear; this.find = find; this.toString = toString; this.insert = insert; this.append = append; this.remove = remove; this.front = front; this.end = end; this.prev = prev; this.next = next; this.length = length; this.currPos = currPos; this.moveTo = moveTo; this.getElement = getElement; this.contains = contains;&#125;function append(element)&#123; this.dataStore[this.listSize++] = element;&#125;function find(element)&#123; for(var i=0;i &lt; this.dataStore.lenhgth;i++)&#123; if(this.dataStore[i] == element)&#123; return i; &#125; &#125; return -1;&#125;function remove(element)&#123; var foundAt = this.find(element); if(foundAt &gt; -1)&#123; this.dataStore.splice(found,1); --this.listSize; return true; &#125; return false;&#125;function length()&#123; return this.listSize;&#125;function toString()&#123; return this.dataStore;&#125;function insert(element, after)&#123; var insertPos = this.find(after); if(insertPos &gt; -1)&#123; this.dataStore.splice(insertPos+1, 0, element); ++this.listSize; return true; &#125; return false;&#125;function clear()&#123; delete this.dataStore;//关于delete的用法重启一章描述 this.dataStore = []; this.listSize = this.pos = 0;&#125;function contains(element)&#123; for(var i=0; i&lt;this.dataStore.length;i++)&#123; if(this.dataStore[i] == element)&#123; return true; &#125; &#125; return false;&#125;function front()&#123; this.pos = 0;&#125;function end()&#123; this.pos = this.listSize - 1;&#125;function prev()&#123; if(this.pos &gt; 0)&#123; --this.pos; &#125;&#125;function next()&#123; if(this.pos&lt;this.listSize-1)&#123; ++this.pos; &#125;&#125;function currPos()&#123; return this.pos;&#125;function moveTo(position)&#123; this.pos = position;&#125;function getElement()&#123; return this.dataStore[this.pos];&#125;迭代器：var names = [2,4,5,5];for(names.front();names.currPos()&lt;names.length();names.next())&#123; console.log(names.getElement());&#125; 栈123456789101112131415161718192021222324function Stack()&#123; this.dataStore = []; this.top = 0; this.push = push; this.pop = pop; this.peek = peek;&#125;function push(element)&#123; this.dataStore[this.top++] = element;&#125;function pop()&#123; return this.dataStore[--this.top];&#125;function peek()&#123; return this.dataStore[this.top-1];&#125;function length()&#123; return this.top;&#125;function clear()&#123; delete this.dataStore;//关于delete的用法重启一章描述 this.dataStore = []; this.top = 0;&#125; 将数字转化为二至九进制的数字 123456789101112function mulBase(num, base)&#123; var s = new Stack(); do&#123; s.push(num%base); num = Math.floor(num/=base); &#125;while(num&gt;0); var converted = \"\"; while(s.length()&gt;0)&#123; converter += s.pop(); &#125; return converted;&#125; 回文判断 12345678910111213141516function isPalindrome(word)&#123; var s = new Stack(); for(var i=0; i&lt;word.length; i++)&#123; s.push(word[i]); &#125; var rword = \"\"; while(s.lenght()&gt;0)&#123; rword += s.pop(); &#125; if(word == rword)&#123; return true; &#125; else&#123; return false; &#125;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"算法","slug":"算法","permalink":"http://memory.lulutia.com/tags/算法/"}]},{"title":"leetcode-JavaScript实现part2","date":"2015-10-12T10:09:00.000Z","path":"2015/10/12/leetcode2/","text":"其他见part1Merge Two Sorted Lists https://leetcode.com/problems/merge-two-sorted-lists/ Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(l1, l2) &#123; var resultNode = new ListNode(0); var result = resultNode; if(l1===null&amp;&amp;l2===null)&#123; return null; &#125; while(l1!==null||l2!==null)&#123; if(l1===null)&#123; result.val = l2.val; l2 = l2.next; if(l2!==null)&#123; result.next = new ListNode(0); result = result.next;&#125; &#125; else if(l2===null)&#123; result.val = l1.val; l1 = l1.next; if(l1!==null)&#123; result.next = new ListNode(0); result = result.next;&#125; &#125; else&#123; if(l1.val&lt;=l2.val)&#123; result.val = l1.val; l1 = l1.next; if(l1!==null||l2!==null)&#123; result.next = new ListNode(0); result = result.next;&#125; &#125; else&#123; result.val = l2.val; l2 = l2.next; if(l1!==null||l2!==null)&#123; result.next = new ListNode(0); result = result.next;&#125; &#125; &#125; &#125; return resultNode;&#125;; Remove Duplicates from Sorted Array https://leetcode.com/problems/remove-duplicates-from-sorted-array/ Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 注意返回的是length 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; if(nums.length===0)&#123; return 0; &#125; if(nums.length===1)&#123; return nums.length; &#125; for(var i=1 ;i&lt;nums.length;i++)&#123; if(nums[i]===nums[i-1])&#123; nums.splice(i,1); i = i-1; &#125; &#125; return nums.length;&#125;; Remove Element https://leetcode.com/problems/remove-element/ Given an array and a value, remove all instances of that value in place and return the new length.The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; val * @return &#123;number&#125; */var removeElement = function(nums, val) &#123; var count = nums.length; if(nums.length===0)&#123; return null; &#125; for(var i=0; i&lt;nums.length;i++)&#123; if(nums[i]===val)&#123; nums.splice(i,1); i = i-1; count = count-1; &#125; &#125; return count;&#125;; Implement strStr() https://leetcode.com/problems/implement-strstr/ mplement strStr().Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 123456789101112131415/** * @param &#123;string&#125; haystack * @param &#123;string&#125; needle * @return &#123;number&#125; */var strStr = function(haystack, needle) &#123; if(haystack.length&lt;needle.length)&#123; return -1; &#125; if(haystack.length===0&amp;&amp;needle.length&gt;0)&#123; return -1; &#125; return haystack.indexOf(needle); &#125;; Valid Sudoku https://leetcode.com/problems/valid-sudoku/ Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’. Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. 简单的说确认是否是有效的数独。即满足每一行、每一列、每一个粗线宫内的数字均含1-9，不重复。 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;character[][]&#125; board * @return &#123;boolean&#125; */var isValidSudoku = function(board) &#123; var array3 = []; for(var q=0;q&lt;3;q++)&#123; array3[q] = []; for(var f=0 ; f&lt;3;f++)&#123; array3[q][f] = [];&#125; &#125; for(var i=0;i&lt;9;i++)&#123; var array = []; var array2 = []; for(var j=0;j&lt;9;j++)&#123; var fir = parseInt(i/3); var sec = parseInt(j/3); if(array3[fir][sec].indexOf(board[i][j])!==-1&amp;&amp;board[i][j]!==\".\")&#123; return false; &#125; if(array.indexOf(board[i][j])!==-1&amp;&amp;board[i][j]!==\".\")&#123; return false; &#125; if(array2.indexOf(board[j][i])!==-1&amp;&amp;board[j][i]!==\".\")&#123; return false; &#125; else &#123; array3[fir][sec].push(board[i][j]); array.push(board[i][j]); array2.push(board[j][i]); &#125; &#125; &#125; return true;&#125;; Length of Last Word https://leetcode.com/problems/length-of-last-word/ Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example, Given s = “Hello World”,return 5. 123456789101112131415161718192021/** * @param &#123;string&#125; s * @return &#123;number&#125; */// var lengthOfLastWord = function(s) &#123;// s = s.trim();// if(s[s.length-1]===\" \")&#123;return 0;&#125;// var arr = s.split(\" \");// return arr[arr.length-1].length;// &#125;;// 上面这种效率太低了var lengthOfLastWord = function(s) &#123; s = s.trim(); if(s[s.length-1]===\" \")&#123;return 0;&#125; for(var i=s.length-1;i&gt;=0;i--)&#123; if(s[i]===\" \")&#123; return s.length-1-i; &#125; &#125; return s.length;&#125;; Plus One https://leetcode.com/problems/plus-one/ Given a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list. 123456789101112131415161718192021222324/** * @param &#123;number[]&#125; digits * @return &#123;number[]&#125; */ //之前用字符串parseInt来做会越界var plusOne = function(digits) &#123; if(digits.length===0)&#123; return [1]; &#125; for(var i=0;i&lt;digits.length;i++)&#123; if(digits[digits.length-i-1]+1&gt;=10)&#123; digits[digits.length-i-1] = 0; if(digits.length-i-1-1&lt;0)&#123; digits.unshift(1); return digits; &#125; flag = true; &#125; else &#123; digits[digits.length-i-1]=digits[digits.length-i-1]+1; return digits; &#125; &#125;&#125;; Climbing Stairs https://leetcode.com/problems/climbing-stairs/ You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 测试可知，其实是一个斐波拉契数列n为1，2，3，4，5时，结果为1，2，3，5，8. 1234567891011121314151617181920/** * @param &#123;number&#125; n * @return &#123;number&#125; */var climbStairs = function(n) &#123; function step(n)&#123; var a=1,b=2; if(n===2)&#123;return b;&#125; if(n===1)&#123;return a;&#125; var sum; n -= 2; while(n--)&#123; sum = a+b; a = b; b = sum; &#125; return sum; &#125; return step(n);&#125;; Remove Duplicates from Sorted List https://leetcode.com/problems/remove-duplicates-from-sorted-list/ Given a sorted linked list, delete all duplicates such that each element appear only once. For example, Given 1-&gt;1-&gt;2, return 1-&gt;2. Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 注意的点：处理最后一位如果为重复的情况,所以放了一个暂时变量tmp，因为链表是有序的，所以只需要对比head的下一个与result的最后一个是否一样。 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var deleteDuplicates = function(head) &#123; if(head===null)&#123;return [];&#125; var outNode = new ListNode(0); var result = outNode; result.val = head.val; while(head.next!==null)&#123; var tmp = head.next; if(tmp.val!==result.val)&#123; result.next = new ListNode(0); result = result.next; result.val = tmp.val; head = head.next &#125; else&#123; head = head.next; &#125; &#125; return outNode;&#125;; Merge Sorted Array https://leetcode.com/problems/merge-sorted-array/ Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 注意的点： 可能数组中有0，但是0是不计入数量的，所以最好一开始就将不符合长度的值去掉。 另外需要处理nums1已经遍历完了，但是nums2还有剩的情况，直接将nums2剩下的加入nums1中，因为本来他们两个就是有序的。 注意不要return。 splice的用法好好体会，记得是在第一个值之前插入。 12345678910111213141516171819202122232425262728293031/** * @param &#123;number[]&#125; nums1 * @param &#123;number&#125; m * @param &#123;number[]&#125; nums2 * @param &#123;number&#125; n * @return &#123;void&#125; Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) &#123; nums1.splice(m); nums2.splice(n); var pp=0; for(var i=0;i&lt;n;i++)&#123; for(var j=pp;j&lt;m;j++)&#123; if(nums2[i]&lt;=nums1[j])&#123; if(j===0)&#123; nums1.unshift(nums2[i]); pp = j + 1; m = m + 1; break; &#125; else&#123; nums1.splice(j,0,nums2[i]); pp = j+1; m = m + 1; break; &#125; &#125; &#125; if(j&gt;=m)&#123;nums1.push(nums2[i])&#125; &#125;&#125;;","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"算法","slug":"算法","permalink":"http://memory.lulutia.com/tags/算法/"}]},{"title":"ES6 learning","date":"2015-10-11T14:38:00.000Z","path":"2015/10/11/ES6/","text":"Environment Prepare Bable node –harmony node –v8-options | grep harmony npm install –global babel babel-node babel-node es6.js babel es6.js -o es5.js babel -d build-dir source-dir babel -d build-dir source-dir -s use Bable in browser: 1234&lt;script src=\"node_modules/babel-core/browser.js\"&gt;&lt;/script&gt;&lt;script type=\"text/babel\"&gt;// Your ES6 code&lt;/script&gt; Traceur 12345678910111213 &lt;!-- 加载Traceur编译器 --&gt;&lt;script src=\"http://google.github.io/traceur-compiler/bin/traceur.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;!-- 将Traceur编译器用于网页 --&gt;&lt;script src=\"http://google.github.io/traceur-compiler/src/bootstrap.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;!-- 打开实验选项，否则有些特性可能编译不成功 --&gt;&lt;script&gt; traceur.options.experimental = true;&lt;/script&gt;&lt;script type=\"module\"&gt; //Your ES6 code&lt;/script&gt; npm install -g traceur traceur es6.js traceur –script es6.js –out es5.js –experimental Some commands let 块级作用域 不存在变量提升 暂时性死区[在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）] 不允许重复声明 块级作用域外部，无法调用块级作用域内部定义的函数 const 声明后不可变 同样是块级作用域，不提升，有暂时性死区，不可重复声明 const命令只是指向变量所在的地址，所以将一个对象声明为常量必须非常小心，因为可以改变其属性 对对象冻结：Object.freeze ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。 跨模块常量：12345export XXX-----import * as XXX from XXX-----import &#123;XXX&#125; from XXX 变量的解构赋值 如果解构不成功，变量的值就等于undefined 解构赋值允许指定默认值 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错,解构不仅可以用于数组，还可以用于对象 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值 不能使用圆括号的情况 变量声明语句中，模式不能带有圆括号 函数参数中，模式不能带有圆括号 不能将整个模式，或嵌套模式中的一层，放在圆括号之中 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号 Iterator Waiting","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"leetcode-JavaScript实现","date":"2015-10-11T10:22:00.000Z","path":"2015/10/11/leetcode/","text":"找工作找的心伤，碰上今年这个动荡的互联网就业年份，刷题安抚下情绪＝＝,然后发现n久之前刷过的几道都过期了，看不到当时的解决了……算了，这次还是存个档吧。 Add Two Numbers https://leetcode.com/problems/add-two-numbers/ You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; var resultNode = new ListNode(0); var result = resultNode; var sum = 0; if(l1===null&amp;&amp;l2===null)&#123; return null; &#125; while(l1!==null||l2!==null)&#123; if(l1!==null)&#123; sum = sum+l1.val; l1 = l1.next; &#125; if(l2!==null)&#123; sum = sum+l2.val; l2 = l2.next; &#125; if(sum&gt;9)&#123; result.val = sum-10; result.next = new ListNode(1); result = result.next; sum = 1; &#125; else&#123; result.val = sum; if(l1!==null||l2!==null)&#123; result.next = new ListNode(0); result = result.next; sum = 0; &#125; &#125; &#125; return resultNode;&#125;; Longest Substring Without Repeating Characters： https://leetcode.com/problems/longest-substring-without-repeating-characters/ Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1. 1234567891011121314151617181920212223/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; var item = \"\"; var num=0; for(var i=0;i&lt;s.length;i++)&#123; if(item.indexOf(s[i])===-1)&#123; item = item + s[i]; var len = item.length; if (len&gt;num)&#123; num = len; &#125; &#125; else&#123; var index = item.indexOf(s[i]); item = item.substr(index+1); item = item+s[i]; &#125; &#125; return num;&#125;; ZigZag Conversion https://leetcode.com/problems/zigzag-conversion/ 简单的说就是从左边开始不停画Z字型路线，然后从上部读取字母拼成输出。 后来网上找了下，这个孩子的分析思路和我的基本一样。 1234567891011121314151617181920212223/** * @param &#123;string&#125; s * @param &#123;number&#125; numRows * @return &#123;string&#125; */var convert = function(s, numRows) &#123; if(s===\"\"||numRows&lt;1||s===null)&#123;return \"\"&#125; if(numRows===1)&#123;return s&#125; if(s.length&lt;=numRows)&#123;return s&#125; var step = 2*numRows - 2; var output=\"\"; for(var i=0; i&lt;numRows; i++ )&#123; for(var j=i; j&lt;s.length; j=j+step)&#123; output += s[j]; if(i!==0&amp;&amp;i!==(numRows-1))&#123; var minStep = step - i*2; if((j+minStep)&lt;s.length)&#123; output += s[j+minStep];&#125; &#125; &#125; &#125; return output;&#125;; Reverse Integer https://leetcode.com/problems/reverse-integer/ Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 12345678910111213141516171819202122/** * @param &#123;number&#125; x * @return &#123;number&#125; */var reverse = function(x) &#123; var flag = false if(x&lt;0)&#123; flag = true; &#125; x = Math.abs(x); var str = x+ \"\"; var out = \"\" for(var i=0;i&lt;str.length;i++)&#123; out += str[str.length-i-1]; &#125; out = parseInt(out); if(out &gt; Number.parseInt(\"1111111111111111111111111111111\", 2))&#123;return 0&#125; if(flag)&#123; out = -out; &#125; return out;&#125;; String to Integer (atoi) https://leetcode.com/problems/string-to-integer-atoi/ Implement atoi to convert a string to an integer. Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;string&#125; str * @return &#123;number&#125; */var myAtoi = function(str) &#123; if(str.length === 0)&#123;return 0;&#125; var count = 0; var flag = false; str = str.trim(); if(str[0]===\"+\"||str[0]===\"-\")&#123; flag = true; if(isNaN(parseInt(str[1])))&#123; return 0; &#125; &#125; if(flag)&#123; for(var i=1 ; i&lt;str.length;i++)&#123; if(isNaN(parseInt(str[i])))&#123; str = str.substr(0,i); &#125; &#125; &#125; else&#123; for(var j=0 ; j&lt;str.length;j++)&#123; if(isNaN(parseInt(str[j]))&amp;&amp;j!==0)&#123; str = str.substr(0,j); &#125; else if(isNaN(parseInt(str[j]))&amp;&amp;j===0)&#123; return 0; &#125; &#125; &#125; if(parseInt(str)&lt;-2147483648) &#123;return -2147483648;&#125; if(parseInt(str)&gt; 2147483647) &#123;return 2147483647;&#125; return parseInt(str);&#125;; Palindrome Number https://leetcode.com/problems/palindrome-number/ Determine whether an integer is a palindrome. Do this without extra space. 12345678910111213141516171819202122232425262728/** * @param &#123;number&#125; x * @return &#123;boolean&#125; */var isPalindrome = function(x) &#123; if(x&lt;0)&#123; return false; &#125; var str = x + \"\"; if(str.length===1)&#123; return true; &#125; if(str.length%2===0)&#123; for(var i=0; i&lt;(str.length/2); i++)&#123; if(str[i]!==str[str.length-1-i])&#123; return false; &#125; &#125; &#125; else&#123; for(var j=0; j&lt;((str.length+1)/2)-1;j++)&#123; if(str[j]!==str[str.length-j-1])&#123; return false; &#125; &#125; &#125; return true;&#125;; Roman to Integer https://leetcode.com/problems/roman-to-integer/ Given a roman numeral, convert it to an integer.Input is guaranteed to be within the range from 1 to 3999. 题目没写具体的罗马数规律，查了一下，如下：罗马数规律 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @param &#123;string&#125; s * @return &#123;number&#125; */var romanToInt = function(s) &#123; var num = []; for(var i=0; i&lt;s.length; i++)&#123; switch(s[i])&#123; case \"I\": num.push(1); break; case \"V\": num.push(5); break; case \"X\": num.push(10); break; case \"L\": num.push(50); break; case \"C\": num.push(100); break; case \"D\": num.push(500); break; case \"M\": num.push(1000); break; &#125; &#125; if(num.length===0)&#123;return 0;&#125; if(num.length===1)&#123;return num[0];&#125; var sum = num[0]; for(var j=1 ;j&lt;num.length;j++)&#123; if(num[j]&lt;=num[j-1])&#123; sum += num[j]; &#125; else&#123; sum = sum - 2*num[j-1] + num[j]; &#125; &#125; return sum;&#125;; Longest Common Prefix https://leetcode.com/problems/longest-common-prefix/ Write a function to find the longest common prefix string amongst an array of strings. 1234567891011121314151617181920212223/** * @param &#123;string[]&#125; strs * @return &#123;string&#125; */var longestCommonPrefix = function(strs) &#123; if(strs.length===0)&#123;return \"\";&#125; var short=strs[0].length; for(var i=0;i&lt;strs.length;i++)&#123; if(strs[i].length&lt;short)&#123; short = strs[i].length; &#125; &#125; var pre = \"\"; for(var j=0;j&lt;short;j++)&#123; for(var k=1;k&lt;strs.length;k++)&#123; if(strs[k][j]!==strs[k-1][j])&#123; return pre; &#125; &#125; pre = pre + strs[0][j]; &#125; return pre;&#125;;","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"算法","slug":"算法","permalink":"http://memory.lulutia.com/tags/算法/"}]},{"title":"留档：Node学习脚印一","date":"2015-10-11T10:21:00.000Z","path":"2015/10/11/Node1/","text":"资料准备部分 Node入门 深入浅出Node.js Node入门部分目标： 用户通过浏览器使用此应用。 当用户请求http://domain/start时，可以看到一个欢迎页面，页面上有一个文件上传的表单。 用户可以选择一个图片并提交表单，随后文件将被上传到http://domain/upload，该页面完成上传后会把图片显示在页面上。 模块分析： Web页面：HTTP服务器 不同的URL：路由 请求处理程序 上传数据 保存展示数据 123456789101112//index.jsvar server = require(\"./server\");var router = require(\"./router\");var requestHandlers = require(\"./requestHandlers\");var handle = &#123;&#125;;handle[\"/\"] = requestHandlers.start;handle[\"/start\"] = requestHandlers.start;handle[\"/upload\"] = requestHandlers.upload;handle[\"/show\"] = requestHandlers.show;server.start(router.router, handle); 12345678910111213141516//server.jsvar http = require(\"http\");var url = require(\"url\");var server = &#123;&#125;;server.start = function(router, handle)&#123; http.createServer(function(req,res)&#123; var pathname = url.parse(req.url).pathname; console.log(\"Request for \" + pathname + \" received\"); router(handle, pathname, res, req); &#125;).listen(8124); console.log(\"Server running at http://127.0.0.1:8124/\");&#125;module.exports = server; 12345678910111213141516//router.jsvar router = &#123;&#125;;router.router = function(handle, pathname, res, req)&#123; console.log(\"About to route a request for \" + pathname); if (typeof handle[pathname] === \"function\")&#123; handle[pathname](res, req); &#125; else&#123; console.log(\"no router \" + pathname); res.writeHead(404, &#123;\"Content-Type\": \"text/plain\"&#125;); res.write(\"404 Not found\"); res.end(); &#125;&#125;module.exports = router; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//requestHandlers.jsvar querystring = require(\"querystring\");var fs = require(\"fs\");var formidable = require(\"formidable\");var requestHandlers = &#123;&#125;;requestHandlers.start = function(res, req)&#123; console.log(\"Request handler 'start' was called.\"); var body = '&lt;html&gt;'+ '&lt;head&gt;'+ '&lt;meta http-equiv=\"Content-Type\" '+ 'content=\"text/html; charset=UTF-8\" /&gt;'+ '&lt;/head&gt;'+ '&lt;body&gt;'+ '&lt;form action=\"/upload\" enctype=\"multipart/form-data\" '+ 'method=\"post\"&gt;'+ '&lt;input type=\"file\" name=\"upload\"&gt;'+ '&lt;input type=\"submit\" value=\"Upload file\" /&gt;'+ '&lt;/form&gt;'+ '&lt;/body&gt;'+ '&lt;/html&gt;'; res.writeHead(200, &#123;\"Content-Type\": \"text/html\"&#125;); res.write(body); res.end();&#125;requestHandlers.upload = function(res, req)&#123; console.log(\"upload\"); var form = new formidable.IncomingForm(); form.parse(req, function(error, fields, files)&#123; console.log(\"parsing done\"); fs.renameSync(files.upload.path, \"/tmp/test.png\"); res.writeHead(\"200\", &#123;\"Content-Type\": \"text/html\"&#125;); res.write(\"received image:&lt;br/&gt;\"); res.write(\"&lt;img src='/show' /&gt;\"); res.end(); &#125;)&#125;requestHandlers.show = function(res, postData)&#123; console.log(\"SHOW\"); fs.readFile(\"/tmp/test.png\", \"binary\", function(error, file)&#123; if(error)&#123; res.writeHead(500, &#123;\"Content-Type\": \"text/plain\"&#125;); res.write(error + \"\\n\"); res.end(); &#125; else&#123; res.writeHead(200, &#123;\"Content-Type\": \"image/png\"&#125;); res.write(file, \"binary\"); res.end(); &#125; &#125;)&#125;module.exports = requestHandlers; 注意点 阻塞和非阻塞的问题","tags":[{"name":"前端","slug":"前端","permalink":"http://memory.lulutia.com/tags/前端/"},{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"}]},{"title":"留档：GitHub＋hexo＋godaddy","date":"2015-09-11T11:22:00.000Z","path":"2015/09/11/hello-world/","text":"环境准备部分 安装Node，去node官网根据自己的机子选择合适的一路傻瓜安装就行了，node安装好了一般npm也集成在里面了。 安装git，我用的是git的客户端SourceTree，选择很多，怎样顺手怎样来。 github部分github是一个开源代码库以及版本控制系统。 申请一个GitHub的账号，路径点击上面链接。 建立项目的仓库，这里根据你希望搭建的博客形式分为了两种方式： 个人或者组织的，这种情况下，你建立的仓库必须与你的用户名保持一致。比如：atmos/atmos.github.io。而且在这个仓库下的master分支将作为内容被建立并且发布到GitHub Pages site。 项目的主页。在这种情况下，可以针对每个具体的项目仓库创建其相对的主页，分支gh-pages作为内容来建立和发布内容。它的访问url一般为username(orgname).github.io/projectname。 总结：如果是希望建立全局性(内容上)的网页建议用第一种方式，否则用第二种方式。详细对比可见GitHub Help。 添加SSH公匙到Account settings －》SSH Keys －》Add SSH Key(其实如果不用SSH连接是可以省略这一步的)，具体过程点击我。将的很详细，跟着走就可以了。 将此仓库克隆到本地(此处需要建立没有历史纪录和操作记录的新分支，所以最好新克隆)，然后创建gh-pages的分支并且将里面的内容都删除，此处不要提交修改。具体过程点击我。 hexo部分hexo是一个快速，简洁高效的博客框架。 在命令行里输入npm install hexo-cli -g进行安装。这里可能会出现几个问题。 需要权限，此时输入变为sudo npm install hexo-cli -g即可。 卡node-gyp rebuild的问题，比如以下错误: 123456789101112node-gyp rebuildgyp WARN install got an error, rolling back installgyp ERR! configure error gyp ERR! stack Error: EPERM, utime '/Users/dirk/.node-gyp/0.12.4'gyp ERR! stack at Error (native)gyp ERR! System Darwin 14.3.0gyp ERR! command \"node\" \"/usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js\" \"rebuild\"gyp ERR! cwd /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-fs/node_modules/chokidar/node_modules/fseventsgyp ERR! node -v v0.12.4gyp ERR! node-gyp -v v1.0.3gyp ERR! not ok npm WARN optional dep failed, continuing fsevents@0.3.6 原因就是GFW啦，所以要使用下国内镜像然后安装，如下： 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org #可能需要sudo$ cnpm install hexo-cli -g 接着执行以下代码，主要就是初始化blog，如果没有指定文件夹则默认就在当下文件夹，然后切换到初始化后的文件夹安装依赖，最后开启本地服务器，此时访问本地http://localhost:4000/就可以了，命令如下： 123hexo init blogcd blognpm install 但是在实际执行中可能会遇见一些问题，比如： 12345[Error: Module did not self-register.]&#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;ERROR Plugin load failed: hexo-generator-feedReferenceError: hexo is not defined 解决方案： 12npm install hexo-generator-feed --savenpm install hexo --save 以上只是部署到了本地，实际上我们需要部署到github上，所以需要去修改hexo的配置，主要修改deploy部分，修改如下,注意type不能写github： 1234deploy: type: git repository: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: gh-pages 然后执行以下命令： 12hexo ghexo deploy 实际中可能遇见的问题，比如： 123&#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; 解决方案： 1npm install hexo-deployer-git --save 主题安装主题寻找地址安装方法也很简单，具体的每个主题下有，大概就是将他们克隆到本地的themes文件夹下，然后修改hexo的配置里的theme为希望的主题。 域名部署 我是之前在godaddy上买过一个域名。 Godaddy注册商域名修改DNS地址。 在DNSPod添加域名后进入控制台添加纪录，这边已经有两条记录了，此时再添加两条，一条是A纪录的host为@指向github的ip，这里是固定的192.30.252.153。另外一条CNAME纪录的host为www指向你的主页.github.io(当然这里也可以通过dig命令获取具体的ip值)，同理，如果是项目主页可以添加二级目录指向.github.io。 在具体的项目下添加一个文件CNAME。里面写上你希望对应的域名，然后提交。接着生成部署hexo就行。 更加详细内容参照。 另外一些参考资料 资料一 资料二","tags":[{"name":"计算机","slug":"计算机","permalink":"http://memory.lulutia.com/tags/计算机/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://memory.lulutia.com/tags/环境搭建/"}]}]